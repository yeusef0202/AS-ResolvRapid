{
  "version": 3,
  "sources": ["../../ol/tilegrid/TileGrid.js", "../../ol/tilegrid.js", "../../ol/source/Tile.js", "../../ol/source/TileEventType.js", "../../ol/tileurlfunction.js", "../../ol/source/UrlTile.js", "../../ol/reproj/common.js", "../../ol/reproj/Triangulation.js", "../../ol/reproj.js", "../../ol/reproj/Tile.js", "../../ol/source/TileImage.js"],
  "sourcesContent": ["/**\r\n * @module ol/tilegrid/TileGrid\r\n */\r\nimport TileRange, {\r\n  createOrUpdate as createOrUpdateTileRange,\r\n} from '../TileRange.js';\r\nimport {DEFAULT_TILE_SIZE} from './common.js';\r\nimport {assert} from '../asserts.js';\r\nimport {ceil, clamp, floor} from '../math.js';\r\nimport {createOrUpdate, getTopLeft} from '../extent.js';\r\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\r\nimport {intersectsLinearRing} from '../geom/flat/intersectsextent.js';\r\nimport {isSorted, linearFindNearest} from '../array.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @private\r\n * @type {import(\"../tilecoord.js\").TileCoord}\r\n */\r\nconst tmpTileCoord = [0, 0, 0];\r\n\r\n/**\r\n * Number of decimal digits to consider in integer values when rounding.\r\n * @type {number}\r\n */\r\nconst DECIMALS = 5;\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\r\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\r\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\r\n * @property {number} [minZoom=0] Minimum zoom.\r\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\r\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\r\n * specified, `extent` or `origins` must be provided.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\r\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\r\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\r\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\r\n * `origin` must be provided.\r\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\r\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\r\n * array will have a length of `maxZoom + 1`.\r\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\r\n * of the grid for each zoom level. If specified the values\r\n * define each zoom level's extent together with the `origin` or `origins`.\r\n * A grid `extent` can be configured in addition, and will further limit the extent\r\n * for which tile requests are made by sources. If the bottom-left corner of\r\n * an extent is used as `origin` or `origins`, then the `y` value must be\r\n * negative because OpenLayers tile coordinates use the top left as the origin.\r\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\r\n * Default is `[256, 256]`.\r\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\r\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\r\n * tile size.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for setting the grid pattern for sources accessing tiled-image\r\n * servers.\r\n * @api\r\n */\r\nclass TileGrid {\r\n  /**\r\n   * @param {Options} options Tile grid options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<number>}\r\n     */\r\n    this.resolutions_ = options.resolutions;\r\n    assert(\r\n      isSorted(\r\n        this.resolutions_,\r\n        function (a, b) {\r\n          return b - a;\r\n        },\r\n        true\r\n      ),\r\n      17\r\n    ); // `resolutions` must be sorted in descending order\r\n\r\n    // check if we've got a consistent zoom factor and origin\r\n    let zoomFactor;\r\n    if (!options.origins) {\r\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\r\n        if (!zoomFactor) {\r\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\r\n        } else {\r\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\r\n            zoomFactor = undefined;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.zoomFactor_ = zoomFactor;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.maxZoom = this.resolutions_.length - 1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate|null}\r\n     */\r\n    this.origin_ = options.origin !== undefined ? options.origin : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\r\n     */\r\n    this.origins_ = null;\r\n    if (options.origins !== undefined) {\r\n      this.origins_ = options.origins;\r\n      assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\r\n    }\r\n\r\n    const extent = options.extent;\r\n\r\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\r\n      this.origin_ = getTopLeft(extent);\r\n    }\r\n\r\n    assert(\r\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\r\n      18\r\n    ); // Either `origin` or `origins` must be configured, never both\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number|import(\"../size.js\").Size>}\r\n     */\r\n    this.tileSizes_ = null;\r\n    if (options.tileSizes !== undefined) {\r\n      this.tileSizes_ = options.tileSizes;\r\n      assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|import(\"../size.js\").Size}\r\n     */\r\n    this.tileSize_ =\r\n      options.tileSize !== undefined\r\n        ? options.tileSize\r\n        : !this.tileSizes_\r\n        ? DEFAULT_TILE_SIZE\r\n        : null;\r\n    assert(\r\n      (!this.tileSize_ && this.tileSizes_) ||\r\n        (this.tileSize_ && !this.tileSizes_),\r\n      22\r\n    ); // Either `tileSize` or `tileSizes` must be configured, never both\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = extent !== undefined ? extent : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../TileRange.js\").default>}\r\n     */\r\n    this.fullTileRanges_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../size.js\").Size}\r\n     */\r\n    this.tmpSize_ = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.tmpExtent_ = [0, 0, 0, 0];\r\n\r\n    if (options.sizes !== undefined) {\r\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\r\n        const tileRange = new TileRange(\r\n          Math.min(0, size[0]),\r\n          Math.max(size[0] - 1, -1),\r\n          Math.min(0, size[1]),\r\n          Math.max(size[1] - 1, -1)\r\n        );\r\n        if (extent) {\r\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\r\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\r\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\r\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\r\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\r\n        }\r\n        return tileRange;\r\n      }, this);\r\n    } else if (extent) {\r\n      this.calculateTileRanges_(extent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call a function with each tile coordinate for a given extent and zoom level.\r\n   *\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} zoom Integer zoom level.\r\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\r\n   * @api\r\n   */\r\n  forEachTileCoord(extent, zoom, callback) {\r\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\r\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\r\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\r\n        callback([zoom, i, j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {boolean} Callback succeeded.\r\n   */\r\n  forEachTileCoordParentTileRange(\r\n    tileCoord,\r\n    callback,\r\n    tempTileRange,\r\n    tempExtent\r\n  ) {\r\n    let tileRange, x, y;\r\n    let tileCoordExtent = null;\r\n    let z = tileCoord[0] - 1;\r\n    if (this.zoomFactor_ === 2) {\r\n      x = tileCoord[1];\r\n      y = tileCoord[2];\r\n    } else {\r\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\r\n    }\r\n    while (z >= this.minZoom) {\r\n      if (this.zoomFactor_ === 2) {\r\n        x = Math.floor(x / 2);\r\n        y = Math.floor(y / 2);\r\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\r\n      } else {\r\n        tileRange = this.getTileRangeForExtentAndZ(\r\n          tileCoordExtent,\r\n          z,\r\n          tempTileRange\r\n        );\r\n      }\r\n      if (callback(z, tileRange)) {\r\n        return true;\r\n      }\r\n      --z;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get the extent for this tile grid, if it was configured.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return this.extent_;\r\n  }\r\n\r\n  /**\r\n   * Get the maximum zoom level for the grid.\r\n   * @return {number} Max zoom.\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return this.maxZoom;\r\n  }\r\n\r\n  /**\r\n   * Get the minimum zoom level for the grid.\r\n   * @return {number} Min zoom.\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return this.minZoom;\r\n  }\r\n\r\n  /**\r\n   * Get the origin for the grid at the given zoom level.\r\n   * @param {number} z Integer zoom level.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\r\n   * @api\r\n   */\r\n  getOrigin(z) {\r\n    if (this.origin_) {\r\n      return this.origin_;\r\n    }\r\n    return this.origins_[z];\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for the given zoom level.\r\n   * @param {number} z Integer zoom level.\r\n   * @return {number} Resolution.\r\n   * @api\r\n   */\r\n  getResolution(z) {\r\n    return this.resolutions_[z];\r\n  }\r\n\r\n  /**\r\n   * Get the list of resolutions for the tile grid.\r\n   * @return {Array<number>} Resolutions.\r\n   * @api\r\n   */\r\n  getResolutions() {\r\n    return this.resolutions_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\r\n   */\r\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\r\n    if (tileCoord[0] < this.maxZoom) {\r\n      if (this.zoomFactor_ === 2) {\r\n        const minX = tileCoord[1] * 2;\r\n        const minY = tileCoord[2] * 2;\r\n        return createOrUpdateTileRange(\r\n          minX,\r\n          minX + 1,\r\n          minY,\r\n          minY + 1,\r\n          tempTileRange\r\n        );\r\n      }\r\n      const tileCoordExtent = this.getTileCoordExtent(\r\n        tileCoord,\r\n        tempExtent || this.tmpExtent_\r\n      );\r\n      return this.getTileRangeForExtentAndZ(\r\n        tileCoordExtent,\r\n        tileCoord[0] + 1,\r\n        tempTileRange\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\r\n   */\r\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\r\n    if (z > this.maxZoom || z < this.minZoom) {\r\n      return null;\r\n    }\r\n\r\n    const tileCoordZ = tileCoord[0];\r\n    const tileCoordX = tileCoord[1];\r\n    const tileCoordY = tileCoord[2];\r\n\r\n    if (z === tileCoordZ) {\r\n      return createOrUpdateTileRange(\r\n        tileCoordX,\r\n        tileCoordY,\r\n        tileCoordX,\r\n        tileCoordY,\r\n        tempTileRange\r\n      );\r\n    }\r\n\r\n    if (this.zoomFactor_) {\r\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\r\n      const minX = Math.floor(tileCoordX * factor);\r\n      const minY = Math.floor(tileCoordY * factor);\r\n      if (z < tileCoordZ) {\r\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\r\n      }\r\n\r\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\r\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\r\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\r\n    }\r\n\r\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\r\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\r\n  }\r\n\r\n  /**\r\n   * Get the extent for a tile range.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   */\r\n  getTileRangeExtent(z, tileRange, tempExtent) {\r\n    const origin = this.getOrigin(z);\r\n    const resolution = this.getResolution(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\r\n    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\r\n    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\r\n    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\r\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\r\n  }\r\n\r\n  /**\r\n   * Get a tile range for the given extent and integer zoom level.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\r\n   * @return {import(\"../TileRange.js\").default} Tile range.\r\n   */\r\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\r\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);\r\n    const minX = tmpTileCoord[1];\r\n    const minY = tmpTileCoord[2];\r\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);\r\n    const maxX = tmpTileCoord[1];\r\n    const maxY = tmpTileCoord[2];\r\n    return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\r\n   */\r\n  getTileCoordCenter(tileCoord) {\r\n    const origin = this.getOrigin(tileCoord[0]);\r\n    const resolution = this.getResolution(tileCoord[0]);\r\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\r\n    return [\r\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\r\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Get the extent of a tile coordinate.\r\n   *\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getTileCoordExtent(tileCoord, tempExtent) {\r\n    const origin = this.getOrigin(tileCoord[0]);\r\n    const resolution = this.getResolution(tileCoord[0]);\r\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\r\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\r\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\r\n    const maxX = minX + tileSize[0] * resolution;\r\n    const maxY = minY + tileSize[1] * resolution;\r\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\r\n  }\r\n\r\n  /**\r\n   * Get the tile coordinate for the given map coordinate and resolution.  This\r\n   * method considers that coordinates that intersect tile boundaries should be\r\n   * assigned the higher tile coordinate.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} resolution Resolution.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\r\n    return this.getTileCoordForXYAndResolution_(\r\n      coordinate[0],\r\n      coordinate[1],\r\n      resolution,\r\n      false,\r\n      opt_tileCoord\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Note that this method should not be called for resolutions that correspond\r\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {number} resolution Resolution (for a non-integer zoom level).\r\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\r\n   *     intersections go to the higher tile coordinate, let edge intersections\r\n   *     go to the lower tile coordinate.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @private\r\n   */\r\n  getTileCoordForXYAndResolution_(\r\n    x,\r\n    y,\r\n    resolution,\r\n    reverseIntersectionPolicy,\r\n    opt_tileCoord\r\n  ) {\r\n    const z = this.getZForResolution(resolution);\r\n    const scale = resolution / this.getResolution(z);\r\n    const origin = this.getOrigin(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n\r\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\r\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\r\n\r\n    if (reverseIntersectionPolicy) {\r\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\r\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\r\n    } else {\r\n      tileCoordX = floor(tileCoordX, DECIMALS);\r\n      tileCoordY = floor(tileCoordY, DECIMALS);\r\n    }\r\n\r\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\r\n  }\r\n\r\n  /**\r\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\r\n   * they should have separate implementations.  This method is for integer zoom\r\n   * levels.  The other method should only be called for resolutions corresponding\r\n   * to non-integer zoom levels.\r\n   * @param {number} x Map x coordinate.\r\n   * @param {number} y Map y coordinate.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\r\n   *     intersections go to the higher tile coordinate, let edge intersections\r\n   *     go to the lower tile coordinate.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @private\r\n   */\r\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\r\n    const origin = this.getOrigin(z);\r\n    const resolution = this.getResolution(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n\r\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\r\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\r\n\r\n    if (reverseIntersectionPolicy) {\r\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\r\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\r\n    } else {\r\n      tileCoordX = floor(tileCoordX, DECIMALS);\r\n      tileCoordY = floor(tileCoordY, DECIMALS);\r\n    }\r\n\r\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\r\n  }\r\n\r\n  /**\r\n   * Get a tile coordinate given a map coordinate and zoom level.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} z Zoom level.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\r\n    return this.getTileCoordForXYAndZ_(\r\n      coordinate[0],\r\n      coordinate[1],\r\n      z,\r\n      false,\r\n      opt_tileCoord\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {number} Tile resolution.\r\n   */\r\n  getTileCoordResolution(tileCoord) {\r\n    return this.resolutions_[tileCoord[0]];\r\n  }\r\n\r\n  /**\r\n   * Get the tile size for a zoom level. The type of the return value matches the\r\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\r\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\r\n   * @param {number} z Z.\r\n   * @return {number|import(\"../size.js\").Size} Tile size.\r\n   * @api\r\n   */\r\n  getTileSize(z) {\r\n    if (this.tileSize_) {\r\n      return this.tileSize_;\r\n    }\r\n    return this.tileSizes_[z];\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Zoom level.\r\n   * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\r\n   */\r\n  getFullTileRange(z) {\r\n    if (!this.fullTileRanges_) {\r\n      return this.extent_\r\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\r\n        : null;\r\n    }\r\n    return this.fullTileRanges_[z];\r\n  }\r\n\r\n  /**\r\n   * @param {number} resolution Resolution.\r\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\r\n   *     If 0, the nearest resolution will be used.\r\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\r\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\r\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\r\n   *\r\n   * For example to change tile Z at the midpoint of zoom levels\r\n   * ```js\r\n   * function(value, high, low) {\r\n   *   return value - low * Math.sqrt(high / low);\r\n   * }\r\n   * ```\r\n   * @return {number} Z.\r\n   * @api\r\n   */\r\n  getZForResolution(resolution, opt_direction) {\r\n    const z = linearFindNearest(\r\n      this.resolutions_,\r\n      resolution,\r\n      opt_direction || 0\r\n    );\r\n    return clamp(z, this.minZoom, this.maxZoom);\r\n  }\r\n\r\n  /**\r\n   * The tile with the provided tile coordinate intersects the given viewport.\r\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\r\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\r\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\r\n   */\r\n  tileCoordIntersectsViewport(tileCoord, viewport) {\r\n    return intersectsLinearRing(\r\n      viewport,\r\n      0,\r\n      viewport.length,\r\n      2,\r\n      this.getTileCoordExtent(tileCoord)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\r\n   * @private\r\n   */\r\n  calculateTileRanges_(extent) {\r\n    const length = this.resolutions_.length;\r\n    const fullTileRanges = new Array(length);\r\n    for (let z = this.minZoom; z < length; ++z) {\r\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\r\n    }\r\n    this.fullTileRanges_ = fullTileRanges;\r\n  }\r\n}\r\n\r\nexport default TileGrid;\r\n", "/**\r\n * @module ol/tilegrid\r\n */\r\nimport TileGrid from './tilegrid/TileGrid.js';\r\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\r\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\r\nimport {\r\n  containsCoordinate,\r\n  createOrUpdate,\r\n  getCorner,\r\n  getHeight,\r\n  getWidth,\r\n} from './extent.js';\r\nimport {toSize} from './size.js';\r\n\r\n/**\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {!TileGrid} Default tile grid for the\r\n * passed projection.\r\n */\r\nexport function getForProjection(projection) {\r\n  let tileGrid = projection.getDefaultTileGrid();\r\n  if (!tileGrid) {\r\n    tileGrid = createForProjection(projection);\r\n    projection.setDefaultTileGrid(tileGrid);\r\n  }\r\n  return tileGrid;\r\n}\r\n\r\n/**\r\n * @param {TileGrid} tileGrid Tile grid.\r\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\r\n */\r\nexport function wrapX(tileGrid, tileCoord, projection) {\r\n  const z = tileCoord[0];\r\n  const center = tileGrid.getTileCoordCenter(tileCoord);\r\n  const projectionExtent = extentFromProjection(projection);\r\n  if (!containsCoordinate(projectionExtent, center)) {\r\n    const worldWidth = getWidth(projectionExtent);\r\n    const worldsAway = Math.ceil(\r\n      (projectionExtent[0] - center[0]) / worldWidth\r\n    );\r\n    center[0] += worldWidth * worldsAway;\r\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\r\n  }\r\n  return tileCoord;\r\n}\r\n\r\n/**\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\r\n * @return {!TileGrid} TileGrid instance.\r\n */\r\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\r\n  corner = corner !== undefined ? corner : 'top-left';\r\n\r\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\r\n\r\n  return new TileGrid({\r\n    extent: extent,\r\n    origin: getCorner(extent, corner),\r\n    resolutions: resolutions,\r\n    tileSize: tileSize,\r\n  });\r\n}\r\n\r\n/**\r\n * @typedef {Object} XYZOptions\r\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\r\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\r\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\r\n * @property {number} [maxResolution] Resolution at level zero.\r\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\r\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\r\n * @property {number} [minZoom=0] Minimum zoom.\r\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\r\n */\r\n\r\n/**\r\n * Creates a tile grid with a standard XYZ tiling scheme.\r\n * @param {XYZOptions} [options] Tile grid options.\r\n * @return {!TileGrid} Tile grid instance.\r\n * @api\r\n */\r\nexport function createXYZ(options) {\r\n  const xyzOptions = options || {};\r\n\r\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\r\n\r\n  const gridOptions = {\r\n    extent: extent,\r\n    minZoom: xyzOptions.minZoom,\r\n    tileSize: xyzOptions.tileSize,\r\n    resolutions: resolutionsFromExtent(\r\n      extent,\r\n      xyzOptions.maxZoom,\r\n      xyzOptions.tileSize,\r\n      xyzOptions.maxResolution\r\n    ),\r\n  };\r\n  return new TileGrid(gridOptions);\r\n}\r\n\r\n/**\r\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {number} [maxResolution] Resolution at level zero.\r\n * @return {!Array<number>} Resolutions array.\r\n */\r\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\r\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\r\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\r\n\r\n  const height = getHeight(extent);\r\n  const width = getWidth(extent);\r\n\r\n  maxResolution =\r\n    maxResolution > 0\r\n      ? maxResolution\r\n      : Math.max(width / tileSize[0], height / tileSize[1]);\r\n\r\n  const length = maxZoom + 1;\r\n  const resolutions = new Array(length);\r\n  for (let z = 0; z < length; ++z) {\r\n    resolutions[z] = maxResolution / Math.pow(2, z);\r\n  }\r\n  return resolutions;\r\n}\r\n\r\n/**\r\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\r\n * @return {!TileGrid} TileGrid instance.\r\n */\r\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\r\n  const extent = extentFromProjection(projection);\r\n  return createForExtent(extent, maxZoom, tileSize, corner);\r\n}\r\n\r\n/**\r\n * Generate a tile grid extent from a projection.  If the projection has an\r\n * extent, it is used.  If not, a global extent is assumed.\r\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\r\n * @return {import(\"./extent.js\").Extent} Extent.\r\n */\r\nexport function extentFromProjection(projection) {\r\n  projection = getProjection(projection);\r\n  let extent = projection.getExtent();\r\n  if (!extent) {\r\n    const half =\r\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\r\n    extent = createOrUpdate(-half, -half, half, half);\r\n  }\r\n  return extent;\r\n}\r\n", "/**\r\n * @module ol/source/Tile\r\n */\r\nimport Event from '../events/Event.js';\r\nimport Source from './Source.js';\r\nimport TileCache from '../TileCache.js';\r\nimport TileState from '../TileState.js';\r\nimport {abstract} from '../util.js';\r\nimport {assert} from '../asserts.js';\r\nimport {equivalent} from '../proj.js';\r\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\r\nimport {\r\n  getForProjection as getTileGridForProjection,\r\n  wrapX,\r\n} from '../tilegrid.js';\r\nimport {scale as scaleSize, toSize} from '../size.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] CacheSize.\r\n * @property {boolean} [opaque=false] Whether the layer is opaque.\r\n * @property {number} [tilePixelRatio] TilePixelRatio.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\r\n * @property {import(\"./Source.js\").State} [state] State.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\r\n * @property {boolean} [wrapX=false] WrapX.\r\n * @property {number} [transition] Transition.\r\n * @property {string} [key] Key.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for sources providing images divided into a tile grid.\r\n * @abstract\r\n * @api\r\n */\r\nclass TileSource extends Source {\r\n  /**\r\n   * @param {Options} options SourceTile source options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      wrapX: options.wrapX,\r\n      interpolate: options.interpolate,\r\n    });\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.tilePixelRatio_ =\r\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\r\n\r\n    /**\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\r\n     */\r\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\r\n\r\n    const tileSize = [256, 256];\r\n    if (this.tileGrid) {\r\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\r\n    }\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../TileCache.js\").default}\r\n     */\r\n    this.tileCache = new TileCache(options.cacheSize || 0);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../size.js\").Size}\r\n     */\r\n    this.tmpSize = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.key_ = options.key || '';\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Tile.js\").Options}\r\n     */\r\n    this.tileOptions = {\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n    };\r\n\r\n    /**\r\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\r\n     * by a renderer if the views resolution does not match any resolution of the tile source.\r\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\r\n     * will be used. If -1, the nearest higher resolution will be used.\r\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\r\n     */\r\n    this.zDirection = options.zDirection ? options.zDirection : 0;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    return this.tileCache.canExpireCache();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    if (tileCache) {\r\n      tileCache.expireCache(usedTiles);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {number} z Zoom level.\r\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\r\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\r\n   *     loaded tile.  If the callback returns `false`, the tile will not be\r\n   *     considered loaded.\r\n   * @return {boolean} The tile range is fully covered with loaded tiles.\r\n   */\r\n  forEachLoadedTile(projection, z, tileRange, callback) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    if (!tileCache) {\r\n      return false;\r\n    }\r\n\r\n    let covered = true;\r\n    let tile, tileCoordKey, loaded;\r\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n        tileCoordKey = getKeyZXY(z, x, y);\r\n        loaded = false;\r\n        if (tileCache.containsKey(tileCoordKey)) {\r\n          tile = /** @type {!import(\"../Tile.js\").default} */ (\r\n            tileCache.get(tileCoordKey)\r\n          );\r\n          loaded = tile.getState() === TileState.LOADED;\r\n          if (loaded) {\r\n            loaded = callback(tile) !== false;\r\n          }\r\n        }\r\n        if (!loaded) {\r\n          covered = false;\r\n        }\r\n      }\r\n    }\r\n    return covered;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutterForProjection(projection) {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Return the key to be used for all tiles in the source.\r\n   * @return {string} The key for all tiles.\r\n   */\r\n  getKey() {\r\n    return this.key_;\r\n  }\r\n\r\n  /**\r\n   * Set the value to be used as the key for all tiles in the source.\r\n   * @param {string} key The key for tiles.\r\n   * @protected\r\n   */\r\n  setKey(key) {\r\n    if (this.key_ !== key) {\r\n      this.key_ = key;\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {boolean} Opaque.\r\n   */\r\n  getOpaque(projection) {\r\n    return this.opaque_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\r\n   * @return {Array<number>|null} Resolutions.\r\n   */\r\n  getResolutions(projection) {\r\n    const tileGrid = projection\r\n      ? this.getTileGridForProjection(projection)\r\n      : this.tileGrid;\r\n    if (!tileGrid) {\r\n      return null;\r\n    }\r\n    return tileGrid.getResolutions();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../Tile.js\").default} Tile.\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the tile grid of the tile source.\r\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\r\n   * @api\r\n   */\r\n  getTileGrid() {\r\n    return this.tileGrid;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    if (!this.tileGrid) {\r\n      return getTileGridForProjection(projection);\r\n    }\r\n    return this.tileGrid;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../TileCache.js\").default} Tile cache.\r\n   * @protected\r\n   */\r\n  getTileCacheForProjection(projection) {\r\n    const sourceProjection = this.getProjection();\r\n    assert(\r\n      sourceProjection === null || equivalent(sourceProjection, projection),\r\n      68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\r\n    );\r\n    return this.tileCache;\r\n  }\r\n\r\n  /**\r\n   * Get the tile pixel ratio for this source. Subclasses may override this\r\n   * method, which is meant to return a supported pixel ratio that matches the\r\n   * provided `pixelRatio` as close as possible.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @return {number} Tile pixel ratio.\r\n   */\r\n  getTilePixelRatio(pixelRatio) {\r\n    return this.tilePixelRatio_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Z.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../size.js\").Size} Tile size.\r\n   */\r\n  getTilePixelSize(z, pixelRatio, projection) {\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\r\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\r\n    if (tilePixelRatio == 1) {\r\n      return tileSize;\r\n    }\r\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\r\n  }\r\n\r\n  /**\r\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\r\n   * is outside the resolution and extent range of the tile grid, `null` will be\r\n   * returned.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\r\n   *     null if no tile URL should be created for the passed `tileCoord`.\r\n   */\r\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\r\n    projection = projection !== undefined ? projection : this.getProjection();\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    if (this.getWrapX() && projection.isGlobal()) {\r\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\r\n    }\r\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\r\n  }\r\n\r\n  /**\r\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\r\n   * @api\r\n   */\r\n  clear() {\r\n    this.tileCache.clear();\r\n  }\r\n\r\n  refresh() {\r\n    this.clear();\r\n    super.refresh();\r\n  }\r\n\r\n  /**\r\n   * Increases the cache size if needed\r\n   * @param {number} tileCount Minimum number of tiles needed.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   */\r\n  updateCacheSize(tileCount, projection) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    if (tileCount > tileCache.highWaterMark) {\r\n      tileCache.highWaterMark = tileCount;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Marks a tile coord as being used, without triggering a load.\r\n   * @abstract\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   */\r\n  useTile(z, x, y, projection) {}\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\r\n * type.\r\n */\r\nexport class TileSourceEvent extends Event {\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../Tile.js\").default} tile The tile.\r\n   */\r\n  constructor(type, tile) {\r\n    super(type);\r\n\r\n    /**\r\n     * The tile related to the event.\r\n     * @type {import(\"../Tile.js\").default}\r\n     * @api\r\n     */\r\n    this.tile = tile;\r\n  }\r\n}\r\n\r\nexport default TileSource;\r\n", "/**\r\n * @module ol/source/TileEventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered when a tile starts loading.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\r\n   * @api\r\n   */\r\n  TILELOADSTART: 'tileloadstart',\r\n\r\n  /**\r\n   * Triggered when a tile finishes loading, either when its data is loaded,\r\n   * or when loading was aborted because the tile is no longer needed.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\r\n   * @api\r\n   */\r\n  TILELOADEND: 'tileloadend',\r\n\r\n  /**\r\n   * Triggered if tile loading results in an error. Note that this is not the\r\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\r\n   * for details.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\r\n   * @api\r\n   */\r\n  TILELOADERROR: 'tileloaderror',\r\n};\r\n\r\n/**\r\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\r\n */\r\n", "/**\r\n * @module ol/tileurlfunction\r\n */\r\nimport {assert} from './asserts.js';\r\nimport {modulo} from './math.js';\r\nimport {hash as tileCoordHash} from './tilecoord.js';\r\n\r\n/**\r\n * @param {string} template Template.\r\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\r\n */\r\nexport function createFromTemplate(template, tileGrid) {\r\n  const zRegEx = /\\{z\\}/g;\r\n  const xRegEx = /\\{x\\}/g;\r\n  const yRegEx = /\\{y\\}/g;\r\n  const dashYRegEx = /\\{-y\\}/g;\r\n  return (\r\n    /**\r\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\r\n     * @param {number} pixelRatio Pixel ratio.\r\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n     * @return {string|undefined} Tile URL.\r\n     */\r\n    function (tileCoord, pixelRatio, projection) {\r\n      if (!tileCoord) {\r\n        return undefined;\r\n      }\r\n      return template\r\n        .replace(zRegEx, tileCoord[0].toString())\r\n        .replace(xRegEx, tileCoord[1].toString())\r\n        .replace(yRegEx, tileCoord[2].toString())\r\n        .replace(dashYRegEx, function () {\r\n          const z = tileCoord[0];\r\n          const range = tileGrid.getFullTileRange(z);\r\n          assert(range, 55); // The {-y} placeholder requires a tile grid with extent\r\n          const y = range.getHeight() - tileCoord[2] - 1;\r\n          return y.toString();\r\n        });\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Array<string>} templates Templates.\r\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\r\n */\r\nexport function createFromTemplates(templates, tileGrid) {\r\n  const len = templates.length;\r\n  const tileUrlFunctions = new Array(len);\r\n  for (let i = 0; i < len; ++i) {\r\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\r\n  }\r\n  return createFromTileUrlFunctions(tileUrlFunctions);\r\n}\r\n\r\n/**\r\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\r\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\r\n */\r\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\r\n  if (tileUrlFunctions.length === 1) {\r\n    return tileUrlFunctions[0];\r\n  }\r\n  return (\r\n    /**\r\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\r\n     * @param {number} pixelRatio Pixel ratio.\r\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n     * @return {string|undefined} Tile URL.\r\n     */\r\n    function (tileCoord, pixelRatio, projection) {\r\n      if (!tileCoord) {\r\n        return undefined;\r\n      }\r\n      const h = tileCoordHash(tileCoord);\r\n      const index = modulo(h, tileUrlFunctions.length);\r\n      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {string|undefined} Tile URL.\r\n */\r\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {string} url URL.\r\n * @return {Array<string>} Array of urls.\r\n */\r\nexport function expandUrl(url) {\r\n  const urls = [];\r\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\r\n  if (match) {\r\n    // char range\r\n    const startCharCode = match[1].charCodeAt(0);\r\n    const stopCharCode = match[2].charCodeAt(0);\r\n    let charCode;\r\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\r\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\r\n    }\r\n    return urls;\r\n  }\r\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\r\n  if (match) {\r\n    // number range\r\n    const stop = parseInt(match[2], 10);\r\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\r\n      urls.push(url.replace(match[0], i.toString()));\r\n    }\r\n    return urls;\r\n  }\r\n  urls.push(url);\r\n  return urls;\r\n}\r\n", "/**\r\n * @module ol/source/UrlTile\r\n */\r\nimport TileEventType from './TileEventType.js';\r\nimport TileSource, {TileSourceEvent} from './Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport {createFromTemplates, expandUrl} from '../tileurlfunction.js';\r\nimport {getKeyZXY} from '../tilecoord.js';\r\nimport {getUid} from '../util.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] Cache size.\r\n * @property {boolean} [opaque=false] Whether the layer is opaque.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\r\n * @property {import(\"./Source.js\").State} [state] State.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\r\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\r\n * @property {number} [tilePixelRatio] TilePixelRatio.\r\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] TileUrlFunction.\r\n * @property {string} [url] Url.\r\n * @property {Array<string>} [urls] Urls.\r\n * @property {boolean} [wrapX=true] WrapX.\r\n * @property {number} [transition] Transition.\r\n * @property {string} [key] Key.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for sources providing tiles divided into a tile grid over http.\r\n *\r\n * @fires import(\"./Tile.js\").TileSourceEvent\r\n */\r\nclass UrlTile extends TileSource {\r\n  /**\r\n   * @param {Options} options Image tile options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      cacheSize: options.cacheSize,\r\n      opaque: options.opaque,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      tileGrid: options.tileGrid,\r\n      tilePixelRatio: options.tilePixelRatio,\r\n      wrapX: options.wrapX,\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n      key: options.key,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      zDirection: options.zDirection,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.generateTileUrlFunction_ =\r\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Tile.js\").LoadFunction}\r\n     */\r\n    this.tileLoadFunction = options.tileLoadFunction;\r\n\r\n    if (options.tileUrlFunction) {\r\n      this.tileUrlFunction = options.tileUrlFunction;\r\n    }\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Array<string>|null}\r\n     */\r\n    this.urls = null;\r\n\r\n    if (options.urls) {\r\n      this.setUrls(options.urls);\r\n    } else if (options.url) {\r\n      this.setUrl(options.url);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, boolean>}\r\n     */\r\n    this.tileLoadingKeys_ = {};\r\n  }\r\n\r\n  /**\r\n   * Return the tile load function of the source.\r\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\r\n   * @api\r\n   */\r\n  getTileLoadFunction() {\r\n    return this.tileLoadFunction;\r\n  }\r\n\r\n  /**\r\n   * Return the tile URL function of the source.\r\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\r\n   * @api\r\n   */\r\n  getTileUrlFunction() {\r\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\r\n      ? this.tileUrlFunction.bind(this)\r\n      : this.tileUrlFunction;\r\n  }\r\n\r\n  /**\r\n   * Return the URLs used for this source.\r\n   * When a tileUrlFunction is used instead of url or urls,\r\n   * null will be returned.\r\n   * @return {!Array<string>|null} URLs.\r\n   * @api\r\n   */\r\n  getUrls() {\r\n    return this.urls;\r\n  }\r\n\r\n  /**\r\n   * Handle tile change events.\r\n   * @param {import(\"../events/Event.js\").default} event Event.\r\n   * @protected\r\n   */\r\n  handleTileChange(event) {\r\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\r\n    const uid = getUid(tile);\r\n    const tileState = tile.getState();\r\n    let type;\r\n    if (tileState == TileState.LOADING) {\r\n      this.tileLoadingKeys_[uid] = true;\r\n      type = TileEventType.TILELOADSTART;\r\n    } else if (uid in this.tileLoadingKeys_) {\r\n      delete this.tileLoadingKeys_[uid];\r\n      type =\r\n        tileState == TileState.ERROR\r\n          ? TileEventType.TILELOADERROR\r\n          : tileState == TileState.LOADED\r\n          ? TileEventType.TILELOADEND\r\n          : undefined;\r\n    }\r\n    if (type != undefined) {\r\n      this.dispatchEvent(new TileSourceEvent(type, tile));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the tile load function of the source.\r\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\r\n   * @api\r\n   */\r\n  setTileLoadFunction(tileLoadFunction) {\r\n    this.tileCache.clear();\r\n    this.tileLoadFunction = tileLoadFunction;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the tile URL function of the source.\r\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\r\n   * @param {string} [key] Optional new tile key for the source.\r\n   * @api\r\n   */\r\n  setTileUrlFunction(tileUrlFunction, key) {\r\n    this.tileUrlFunction = tileUrlFunction;\r\n    this.tileCache.pruneExceptNewestZ();\r\n    if (typeof key !== 'undefined') {\r\n      this.setKey(key);\r\n    } else {\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the URL to use for requests.\r\n   * @param {string} url URL.\r\n   * @api\r\n   */\r\n  setUrl(url) {\r\n    const urls = expandUrl(url);\r\n    this.urls = urls;\r\n    this.setUrls(urls);\r\n  }\r\n\r\n  /**\r\n   * Set the URLs to use for requests.\r\n   * @param {Array<string>} urls URLs.\r\n   * @api\r\n   */\r\n  setUrls(urls) {\r\n    this.urls = urls;\r\n    const key = urls.join('\\n');\r\n    if (this.generateTileUrlFunction_) {\r\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\r\n    } else {\r\n      this.setKey(key);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {string|undefined} Tile URL.\r\n   */\r\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Marks a tile coord as being used, without triggering a load.\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   */\r\n  useTile(z, x, y) {\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    if (this.tileCache.containsKey(tileCoordKey)) {\r\n      this.tileCache.get(tileCoordKey);\r\n    }\r\n  }\r\n}\r\n\r\nexport default UrlTile;\r\n", "/**\r\n * @module ol/reproj/common\r\n */\r\n\r\n/**\r\n * Default maximum allowed threshold  (in pixels) for reprojection\r\n * triangulation.\r\n * @type {number}\r\n */\r\nexport const ERROR_THRESHOLD = 0.5;\r\n", "/**\r\n * @module ol/reproj/Triangulation\r\n */\r\nimport {\r\n  boundingExtent,\r\n  createEmpty,\r\n  extendCoordinate,\r\n  getArea,\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getTopLeft,\r\n  getTopRight,\r\n  getWidth,\r\n  intersects,\r\n} from '../extent.js';\r\nimport {getTransform} from '../proj.js';\r\nimport {modulo} from '../math.js';\r\n\r\n/**\r\n * Single triangle; consists of 3 source points and 3 target points.\r\n * @typedef {Object} Triangle\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\r\n */\r\n\r\n/**\r\n * Maximum number of subdivision steps during raster reprojection triangulation.\r\n * Prevents high memory usage and large number of proj4 calls (for certain\r\n * transformations and areas). At most `2*(2^this)` triangles are created for\r\n * each triangulated extent (tile/image).\r\n * @type {number}\r\n */\r\nconst MAX_SUBDIVISION = 10;\r\n\r\n/**\r\n * Maximum allowed size of triangle relative to world width. When transforming\r\n * corners of world extent between certain projections, the resulting\r\n * triangulation seems to have zero error and no subdivision is performed. If\r\n * the triangle width is more than this (relative to world width; 0-1),\r\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\r\n * @type {number}\r\n */\r\nconst MAX_TRIANGLE_WIDTH = 0.25;\r\n\r\n/**\r\n * @classdesc\r\n * Class containing triangulation of the given target extent.\r\n * Used for determining source data and the reprojection itself.\r\n */\r\nclass Triangulation {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\r\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\r\n   * @param {number} errorThreshold Acceptable error (in source units).\r\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    targetProj,\r\n    targetExtent,\r\n    maxSourceExtent,\r\n    errorThreshold,\r\n    destinationResolution\r\n  ) {\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.sourceProj_ = sourceProj;\r\n\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.targetProj_ = targetProj;\r\n\r\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\r\n    let transformInvCache = {};\r\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\r\n\r\n    /**\r\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\r\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\r\n     * @private\r\n     */\r\n    this.transformInv_ = function (c) {\r\n      const key = c[0] + '/' + c[1];\r\n      if (!transformInvCache[key]) {\r\n        transformInvCache[key] = transformInv(c);\r\n      }\r\n      return transformInvCache[key];\r\n    };\r\n\r\n    /**\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\r\n    this.maxSourceExtent_ = maxSourceExtent;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\r\n\r\n    /**\r\n     * @type {Array<Triangle>}\r\n     * @private\r\n     */\r\n    this.triangles_ = [];\r\n\r\n    /**\r\n     * Indicates that the triangulation crosses edge of the source projection.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.wrapsXInSource_ = false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.canWrapXInSource_ =\r\n      this.sourceProj_.canWrapX() &&\r\n      !!maxSourceExtent &&\r\n      !!this.sourceProj_.getExtent() &&\r\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\r\n      ? getWidth(this.sourceProj_.getExtent())\r\n      : null;\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\r\n      ? getWidth(this.targetProj_.getExtent())\r\n      : null;\r\n\r\n    const destinationTopLeft = getTopLeft(targetExtent);\r\n    const destinationTopRight = getTopRight(targetExtent);\r\n    const destinationBottomRight = getBottomRight(targetExtent);\r\n    const destinationBottomLeft = getBottomLeft(targetExtent);\r\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\r\n    const sourceTopRight = this.transformInv_(destinationTopRight);\r\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\r\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\r\n\r\n    /*\r\n     * The maxSubdivision controls how many splittings of the target area can\r\n     * be done. The idea here is to do a linear mapping of the target areas\r\n     * but the actual overal reprojection (can be) extremely non-linear. The\r\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\r\n     * tile size. However this function is also called to remap canvas rendered\r\n     * layers which can be much larger. This calculation increases the maxSubdivision\r\n     * value by the right factor so that each 256x256 pixel area has\r\n     * MAX_SUBDIVISION divisions.\r\n     */\r\n    const maxSubdivision =\r\n      MAX_SUBDIVISION +\r\n      (destinationResolution\r\n        ? Math.max(\r\n            0,\r\n            Math.ceil(\r\n              Math.log2(\r\n                getArea(targetExtent) /\r\n                  (destinationResolution * destinationResolution * 256 * 256)\r\n              )\r\n            )\r\n          )\r\n        : 0);\r\n\r\n    this.addQuad_(\r\n      destinationTopLeft,\r\n      destinationTopRight,\r\n      destinationBottomRight,\r\n      destinationBottomLeft,\r\n      sourceTopLeft,\r\n      sourceTopRight,\r\n      sourceBottomRight,\r\n      sourceBottomLeft,\r\n      maxSubdivision\r\n    );\r\n\r\n    if (this.wrapsXInSource_) {\r\n      let leftBound = Infinity;\r\n      this.triangles_.forEach(function (triangle, i, arr) {\r\n        leftBound = Math.min(\r\n          leftBound,\r\n          triangle.source[0][0],\r\n          triangle.source[1][0],\r\n          triangle.source[2][0]\r\n        );\r\n      });\r\n\r\n      // Shift triangles to be as close to `leftBound` as possible\r\n      // (if the distance is more than `worldWidth / 2` it can be closer.\r\n      this.triangles_.forEach((triangle) => {\r\n        if (\r\n          Math.max(\r\n            triangle.source[0][0],\r\n            triangle.source[1][0],\r\n            triangle.source[2][0]\r\n          ) -\r\n            leftBound >\r\n          this.sourceWorldWidth_ / 2\r\n        ) {\r\n          const newTriangle = [\r\n            [triangle.source[0][0], triangle.source[0][1]],\r\n            [triangle.source[1][0], triangle.source[1][1]],\r\n            [triangle.source[2][0], triangle.source[2][1]],\r\n          ];\r\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[0][0] -= this.sourceWorldWidth_;\r\n          }\r\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[1][0] -= this.sourceWorldWidth_;\r\n          }\r\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[2][0] -= this.sourceWorldWidth_;\r\n          }\r\n\r\n          // Rarely (if the extent contains both the dateline and prime meridian)\r\n          // the shift can in turn break some triangles.\r\n          // Detect this here and don't shift in such cases.\r\n          const minX = Math.min(\r\n            newTriangle[0][0],\r\n            newTriangle[1][0],\r\n            newTriangle[2][0]\r\n          );\r\n          const maxX = Math.max(\r\n            newTriangle[0][0],\r\n            newTriangle[1][0],\r\n            newTriangle[2][0]\r\n          );\r\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\r\n            triangle.source = newTriangle;\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    transformInvCache = {};\r\n  }\r\n\r\n  /**\r\n   * Adds triangle to the triangulation.\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @private\r\n   */\r\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\r\n    this.triangles_.push({\r\n      source: [aSrc, bSrc, cSrc],\r\n      target: [a, b, c],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds quad (points in clock-wise order) to the triangulation\r\n   * (and reprojects the vertices) if valid.\r\n   * Performs quad subdivision if needed to increase precision.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\r\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\r\n   * @private\r\n   */\r\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\r\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\r\n    const sourceCoverageX = this.sourceWorldWidth_\r\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\r\n      : null;\r\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\r\n\r\n    // when the quad is wrapped in the source projection\r\n    // it covers most of the projection extent, but not fully\r\n    const wrapsX =\r\n      this.sourceProj_.canWrapX() &&\r\n      sourceCoverageX > 0.5 &&\r\n      sourceCoverageX < 1;\r\n\r\n    let needsSubdivision = false;\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\r\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\r\n        const targetCoverageX =\r\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\r\n        needsSubdivision =\r\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\r\n        needsSubdivision =\r\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n    }\r\n\r\n    if (!needsSubdivision && this.maxSourceExtent_) {\r\n      if (\r\n        isFinite(sourceQuadExtent[0]) &&\r\n        isFinite(sourceQuadExtent[1]) &&\r\n        isFinite(sourceQuadExtent[2]) &&\r\n        isFinite(sourceQuadExtent[3])\r\n      ) {\r\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\r\n          // whole quad outside source projection extent -> ignore\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    let isNotFinite = 0;\r\n\r\n    if (!needsSubdivision) {\r\n      if (\r\n        !isFinite(aSrc[0]) ||\r\n        !isFinite(aSrc[1]) ||\r\n        !isFinite(bSrc[0]) ||\r\n        !isFinite(bSrc[1]) ||\r\n        !isFinite(cSrc[0]) ||\r\n        !isFinite(cSrc[1]) ||\r\n        !isFinite(dSrc[0]) ||\r\n        !isFinite(dSrc[1])\r\n      ) {\r\n        if (maxSubdivision > 0) {\r\n          needsSubdivision = true;\r\n        } else {\r\n          // It might be the case that only 1 of the points is infinite. In this case\r\n          // we can draw a single triangle with the other three points\r\n          isNotFinite =\r\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\r\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\r\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\r\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\r\n          if (\r\n            isNotFinite != 1 &&\r\n            isNotFinite != 2 &&\r\n            isNotFinite != 4 &&\r\n            isNotFinite != 8\r\n          ) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (!needsSubdivision) {\r\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\r\n        const centerSrc = this.transformInv_(center);\r\n\r\n        let dx;\r\n        if (wrapsX) {\r\n          const centerSrcEstimX =\r\n            (modulo(aSrc[0], sourceWorldWidth) +\r\n              modulo(cSrc[0], sourceWorldWidth)) /\r\n            2;\r\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\r\n        } else {\r\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\r\n        }\r\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\r\n        const centerSrcErrorSquared = dx * dx + dy * dy;\r\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\r\n      }\r\n      if (needsSubdivision) {\r\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\r\n          // split horizontally (top & bottom)\r\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\r\n          const bcSrc = this.transformInv_(bc);\r\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\r\n          const daSrc = this.transformInv_(da);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            b,\r\n            bc,\r\n            da,\r\n            aSrc,\r\n            bSrc,\r\n            bcSrc,\r\n            daSrc,\r\n            maxSubdivision - 1\r\n          );\r\n          this.addQuad_(\r\n            da,\r\n            bc,\r\n            c,\r\n            d,\r\n            daSrc,\r\n            bcSrc,\r\n            cSrc,\r\n            dSrc,\r\n            maxSubdivision - 1\r\n          );\r\n        } else {\r\n          // split vertically (left & right)\r\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\r\n          const abSrc = this.transformInv_(ab);\r\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\r\n          const cdSrc = this.transformInv_(cd);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            ab,\r\n            cd,\r\n            d,\r\n            aSrc,\r\n            abSrc,\r\n            cdSrc,\r\n            dSrc,\r\n            maxSubdivision - 1\r\n          );\r\n          this.addQuad_(\r\n            ab,\r\n            b,\r\n            c,\r\n            cd,\r\n            abSrc,\r\n            bSrc,\r\n            cSrc,\r\n            cdSrc,\r\n            maxSubdivision - 1\r\n          );\r\n        }\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (wrapsX) {\r\n      if (!this.canWrapXInSource_) {\r\n        return;\r\n      }\r\n      this.wrapsXInSource_ = true;\r\n    }\r\n\r\n    // Exactly zero or one of *Src is not finite\r\n    // The triangles must have the diagonal line as the first side\r\n    // This is to allow easy code in reproj.s to make it straight for broken\r\n    // browsers that can't handle diagonal clipping\r\n    if ((isNotFinite & 0xb) == 0) {\r\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\r\n    }\r\n    if ((isNotFinite & 0xe) == 0) {\r\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\r\n    }\r\n    if (isNotFinite) {\r\n      // Try the other two triangles\r\n      if ((isNotFinite & 0xd) == 0) {\r\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\r\n      }\r\n      if ((isNotFinite & 0x7) == 0) {\r\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates extent of the `source` coordinates from all the triangles.\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\r\n   */\r\n  calculateSourceExtent() {\r\n    const extent = createEmpty();\r\n\r\n    this.triangles_.forEach(function (triangle, i, arr) {\r\n      const src = triangle.source;\r\n      extendCoordinate(extent, src[0]);\r\n      extendCoordinate(extent, src[1]);\r\n      extendCoordinate(extent, src[2]);\r\n    });\r\n\r\n    return extent;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Triangle>} Array of the calculated triangles.\r\n   */\r\n  getTriangles() {\r\n    return this.triangles_;\r\n  }\r\n}\r\n\r\nexport default Triangulation;\r\n", "/**\r\n * @module ol/reproj\r\n */\r\nimport {\r\n  containsCoordinate,\r\n  createEmpty,\r\n  extend,\r\n  forEachCorner,\r\n  getCenter,\r\n  getHeight,\r\n  getTopLeft,\r\n  getWidth,\r\n} from './extent.js';\r\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\r\nimport {getPointResolution, transform} from './proj.js';\r\nimport {solveLinearSystem} from './math.js';\r\n\r\nlet brokenDiagonalRendering_;\r\n\r\n/**\r\n * @type {Array<HTMLCanvasElement>}\r\n */\r\nexport const canvasPool = [];\r\n\r\n/**\r\n * This draws a small triangle into a canvas by setting the triangle as the clip region\r\n * and then drawing a (too large) rectangle\r\n *\r\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\r\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\r\n * @param {number} v1 The y-coordinate of the second point.\r\n * @param {number} u2 The x-coordinate of the third point.\r\n * @param {number} v2 The y-coordinate of the third point.\r\n */\r\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(0, 0);\r\n  ctx.lineTo(u1, v1);\r\n  ctx.lineTo(u2, v2);\r\n  ctx.closePath();\r\n  ctx.save();\r\n  ctx.clip();\r\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * Given the data from getImageData, see if the right values appear at the provided offset.\r\n * Returns true if either the color or transparency is off\r\n *\r\n * @param {Uint8ClampedArray} data The data returned from getImageData\r\n * @param {number} offset The pixel offset from the start of data.\r\n * @return {boolean} true if the diagonal rendering is broken\r\n */\r\nfunction verifyBrokenDiagonalRendering(data, offset) {\r\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\r\n  return (\r\n    Math.abs(data[offset * 4] - 210) > 2 ||\r\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\r\n  );\r\n}\r\n\r\n/**\r\n * Determines if the current browser configuration can render triangular clip regions correctly.\r\n * This value is cached so the function is only expensive the first time called.\r\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\r\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\r\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\r\n * running, but lets hope not.\r\n *\r\n * @return {boolean} true if the Diagonal Rendering is broken.\r\n */\r\nfunction isBrokenDiagonalRendering() {\r\n  if (brokenDiagonalRendering_ === undefined) {\r\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\r\n    ctx.globalCompositeOperation = 'lighter';\r\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\r\n    drawTestTriangle(ctx, 4, 5, 4, 0);\r\n    drawTestTriangle(ctx, 4, 5, 0, 5);\r\n    const data = ctx.getImageData(0, 0, 3, 3).data;\r\n    brokenDiagonalRendering_ =\r\n      verifyBrokenDiagonalRendering(data, 0) ||\r\n      verifyBrokenDiagonalRendering(data, 4) ||\r\n      verifyBrokenDiagonalRendering(data, 8);\r\n    releaseCanvas(ctx);\r\n    canvasPool.push(ctx.canvas);\r\n  }\r\n\r\n  return brokenDiagonalRendering_;\r\n}\r\n\r\n/**\r\n * Calculates ideal resolution to use from the source in order to achieve\r\n * pixel mapping as close as possible to 1:1 during reprojection.\r\n * The resolution is calculated regardless of what resolutions\r\n * are actually available in the dataset (TileGrid, Image, ...).\r\n *\r\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\r\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\r\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\r\n * @param {number} targetResolution Target resolution.\r\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\r\n */\r\nexport function calculateSourceResolution(\r\n  sourceProj,\r\n  targetProj,\r\n  targetCenter,\r\n  targetResolution\r\n) {\r\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\r\n\r\n  // calculate the ideal resolution of the source data\r\n  let sourceResolution = getPointResolution(\r\n    targetProj,\r\n    targetResolution,\r\n    targetCenter\r\n  );\r\n\r\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\r\n  if (targetMetersPerUnit !== undefined) {\r\n    sourceResolution *= targetMetersPerUnit;\r\n  }\r\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\r\n  if (sourceMetersPerUnit !== undefined) {\r\n    sourceResolution /= sourceMetersPerUnit;\r\n  }\r\n\r\n  // Based on the projection properties, the point resolution at the specified\r\n  // coordinates may be slightly different. We need to reverse-compensate this\r\n  // in order to achieve optimal results.\r\n\r\n  const sourceExtent = sourceProj.getExtent();\r\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\r\n    const compensationFactor =\r\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\r\n      sourceResolution;\r\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\r\n      sourceResolution /= compensationFactor;\r\n    }\r\n  }\r\n\r\n  return sourceResolution;\r\n}\r\n\r\n/**\r\n * Calculates ideal resolution to use from the source in order to achieve\r\n * pixel mapping as close as possible to 1:1 during reprojection.\r\n * The resolution is calculated regardless of what resolutions\r\n * are actually available in the dataset (TileGrid, Image, ...).\r\n *\r\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\r\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\r\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\r\n * @param {number} targetResolution Target resolution.\r\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\r\n */\r\nexport function calculateSourceExtentResolution(\r\n  sourceProj,\r\n  targetProj,\r\n  targetExtent,\r\n  targetResolution\r\n) {\r\n  const targetCenter = getCenter(targetExtent);\r\n  let sourceResolution = calculateSourceResolution(\r\n    sourceProj,\r\n    targetProj,\r\n    targetCenter,\r\n    targetResolution\r\n  );\r\n\r\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n    forEachCorner(targetExtent, function (corner) {\r\n      sourceResolution = calculateSourceResolution(\r\n        sourceProj,\r\n        targetProj,\r\n        corner,\r\n        targetResolution\r\n      );\r\n      return isFinite(sourceResolution) && sourceResolution > 0;\r\n    });\r\n  }\r\n\r\n  return sourceResolution;\r\n}\r\n\r\n/**\r\n * @typedef {Object} ImageExtent\r\n * @property {import(\"./extent.js\").Extent} extent Extent.\r\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\r\n */\r\n\r\n/**\r\n * Renders the source data into new canvas based on the triangulation.\r\n *\r\n * @param {number} width Width of the canvas.\r\n * @param {number} height Height of the canvas.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {number} sourceResolution Source resolution.\r\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\r\n * @param {number} targetResolution Target resolution.\r\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\r\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\r\n * @param {Array<ImageExtent>} sources Array of sources.\r\n * @param {number} gutter Gutter of the sources.\r\n * @param {boolean} [renderEdges] Render reprojection edges.\r\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\r\n * @return {HTMLCanvasElement} Canvas with reprojected data.\r\n */\r\nexport function render(\r\n  width,\r\n  height,\r\n  pixelRatio,\r\n  sourceResolution,\r\n  sourceExtent,\r\n  targetResolution,\r\n  targetExtent,\r\n  triangulation,\r\n  sources,\r\n  gutter,\r\n  renderEdges,\r\n  interpolate\r\n) {\r\n  const context = createCanvasContext2D(\r\n    Math.round(pixelRatio * width),\r\n    Math.round(pixelRatio * height),\r\n    canvasPool\r\n  );\r\n\r\n  if (!interpolate) {\r\n    context.imageSmoothingEnabled = false;\r\n  }\r\n\r\n  if (sources.length === 0) {\r\n    return context.canvas;\r\n  }\r\n\r\n  context.scale(pixelRatio, pixelRatio);\r\n\r\n  function pixelRound(value) {\r\n    return Math.round(value * pixelRatio) / pixelRatio;\r\n  }\r\n\r\n  context.globalCompositeOperation = 'lighter';\r\n\r\n  const sourceDataExtent = createEmpty();\r\n  sources.forEach(function (src, i, arr) {\r\n    extend(sourceDataExtent, src.extent);\r\n  });\r\n\r\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\r\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\r\n  const stitchContext = createCanvasContext2D(\r\n    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\r\n    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution),\r\n    canvasPool\r\n  );\r\n\r\n  if (!interpolate) {\r\n    stitchContext.imageSmoothingEnabled = false;\r\n  }\r\n\r\n  const stitchScale = pixelRatio / sourceResolution;\r\n\r\n  sources.forEach(function (src, i, arr) {\r\n    const xPos = src.extent[0] - sourceDataExtent[0];\r\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\r\n    const srcWidth = getWidth(src.extent);\r\n    const srcHeight = getHeight(src.extent);\r\n\r\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\r\n    if (src.image.width > 0 && src.image.height > 0) {\r\n      stitchContext.drawImage(\r\n        src.image,\r\n        gutter,\r\n        gutter,\r\n        src.image.width - 2 * gutter,\r\n        src.image.height - 2 * gutter,\r\n        xPos * stitchScale,\r\n        yPos * stitchScale,\r\n        srcWidth * stitchScale,\r\n        srcHeight * stitchScale\r\n      );\r\n    }\r\n  });\r\n\r\n  const targetTopLeft = getTopLeft(targetExtent);\r\n\r\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n    /* Calculate affine transform (src -> dst)\r\n     * Resulting matrix can be used to transform coordinate\r\n     * from `sourceProjection` to destination pixels.\r\n     *\r\n     * To optimize number of context calls and increase numerical stability,\r\n     * we also do the following operations:\r\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\r\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\r\n     *\r\n     * Src points: xi, yi\r\n     * Dst points: ui, vi\r\n     * Affine coefficients: aij\r\n     *\r\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\r\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\r\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\r\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\r\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\r\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\r\n     */\r\n    const source = triangle.source;\r\n    const target = triangle.target;\r\n    let x0 = source[0][0],\r\n      y0 = source[0][1];\r\n    let x1 = source[1][0],\r\n      y1 = source[1][1];\r\n    let x2 = source[2][0],\r\n      y2 = source[2][1];\r\n    // Make sure that everything is on pixel boundaries\r\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\r\n    const v0 = pixelRound(\r\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\r\n    );\r\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\r\n    const v1 = pixelRound(\r\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\r\n    );\r\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\r\n    const v2 = pixelRound(\r\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\r\n    );\r\n\r\n    // Shift all the source points to improve numerical stability\r\n    // of all the subsequent calculations. The [x0, y0] is used here.\r\n    // This is also used to simplify the linear system.\r\n    const sourceNumericalShiftX = x0;\r\n    const sourceNumericalShiftY = y0;\r\n    x0 = 0;\r\n    y0 = 0;\r\n    x1 -= sourceNumericalShiftX;\r\n    y1 -= sourceNumericalShiftY;\r\n    x2 -= sourceNumericalShiftX;\r\n    y2 -= sourceNumericalShiftY;\r\n\r\n    const augmentedMatrix = [\r\n      [x1, y1, 0, 0, u1 - u0],\r\n      [x2, y2, 0, 0, u2 - u0],\r\n      [0, 0, x1, y1, v1 - v0],\r\n      [0, 0, x2, y2, v2 - v0],\r\n    ];\r\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\r\n    if (!affineCoefs) {\r\n      return;\r\n    }\r\n\r\n    context.save();\r\n    context.beginPath();\r\n\r\n    if (isBrokenDiagonalRendering() || !interpolate) {\r\n      // Make sure that all lines are horizontal or vertical\r\n      context.moveTo(u1, v1);\r\n      // This is the diagonal line. Do it in 4 steps\r\n      const steps = 4;\r\n      const ud = u0 - u1;\r\n      const vd = v0 - v1;\r\n      for (let step = 0; step < steps; step++) {\r\n        // Go horizontally\r\n        context.lineTo(\r\n          u1 + pixelRound(((step + 1) * ud) / steps),\r\n          v1 + pixelRound((step * vd) / (steps - 1))\r\n        );\r\n        // Go vertically\r\n        if (step != steps - 1) {\r\n          context.lineTo(\r\n            u1 + pixelRound(((step + 1) * ud) / steps),\r\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\r\n          );\r\n        }\r\n      }\r\n      // We are almost at u0r, v0r\r\n      context.lineTo(u2, v2);\r\n    } else {\r\n      context.moveTo(u1, v1);\r\n      context.lineTo(u0, v0);\r\n      context.lineTo(u2, v2);\r\n    }\r\n\r\n    context.clip();\r\n\r\n    context.transform(\r\n      affineCoefs[0],\r\n      affineCoefs[2],\r\n      affineCoefs[1],\r\n      affineCoefs[3],\r\n      u0,\r\n      v0\r\n    );\r\n\r\n    context.translate(\r\n      sourceDataExtent[0] - sourceNumericalShiftX,\r\n      sourceDataExtent[3] - sourceNumericalShiftY\r\n    );\r\n\r\n    context.scale(\r\n      sourceResolution / pixelRatio,\r\n      -sourceResolution / pixelRatio\r\n    );\r\n\r\n    context.drawImage(stitchContext.canvas, 0, 0);\r\n    context.restore();\r\n  });\r\n\r\n  releaseCanvas(stitchContext);\r\n  canvasPool.push(stitchContext.canvas);\r\n\r\n  if (renderEdges) {\r\n    context.save();\r\n\r\n    context.globalCompositeOperation = 'source-over';\r\n    context.strokeStyle = 'black';\r\n    context.lineWidth = 1;\r\n\r\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n      const target = triangle.target;\r\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\r\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\r\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\r\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\r\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\r\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\r\n\r\n      context.beginPath();\r\n      context.moveTo(u1, v1);\r\n      context.lineTo(u0, v0);\r\n      context.lineTo(u2, v2);\r\n      context.closePath();\r\n      context.stroke();\r\n    });\r\n\r\n    context.restore();\r\n  }\r\n  return context.canvas;\r\n}\r\n", "/**\r\n * @module ol/reproj/Tile\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport Tile from '../Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceExtentResolution,\r\n  canvasPool,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {clamp} from '../math.js';\r\nimport {getArea, getIntersection} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\nimport {releaseCanvas} from '../dom.js';\r\n\r\n/**\r\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected tile.\r\n * See {@link module:ol/source/TileImage~TileImage}.\r\n *\r\n */\r\nclass ReprojTile extends Tile {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} gutter Gutter of the source tiles.\r\n   * @param {FunctionType} getTileFunction\r\n   *     Function returning source tiles (z, x, y, pixelRatio).\r\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\r\n   * @param {boolean} [renderEdges] Render reprojection edges.\r\n   * @param {boolean} [interpolate] Use linear interpolation when resampling.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    sourceTileGrid,\r\n    targetProj,\r\n    targetTileGrid,\r\n    tileCoord,\r\n    wrappedTileCoord,\r\n    pixelRatio,\r\n    gutter,\r\n    getTileFunction,\r\n    errorThreshold,\r\n    renderEdges,\r\n    interpolate\r\n  ) {\r\n    super(tileCoord, TileState.IDLE, {interpolate: !!interpolate});\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = gutter;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.sourceTileGrid_ = sourceTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.targetTileGrid_ = targetTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<import(\"../ImageTile.js\").default>}\r\n     */\r\n    this.sourceTiles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.sourcesListenerKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourceZ_ = 0;\r\n\r\n    const targetExtent = targetTileGrid.getTileCoordExtent(\r\n      this.wrappedTileCoord_\r\n    );\r\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\r\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    if (getArea(limitedTargetExtent) === 0) {\r\n      // Tile is completely outside range -> EMPTY\r\n      // TODO: is it actually correct that the source even creates the tile ?\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const sourceProjExtent = sourceProj.getExtent();\r\n    if (sourceProjExtent) {\r\n      if (!maxSourceExtent) {\r\n        maxSourceExtent = sourceProjExtent;\r\n      } else {\r\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\r\n      }\r\n    }\r\n\r\n    const targetResolution = targetTileGrid.getResolution(\r\n      this.wrappedTileCoord_[0]\r\n    );\r\n\r\n    const sourceResolution = calculateSourceExtentResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      targetResolution\r\n    );\r\n\r\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n      // invalid sourceResolution -> EMPTY\r\n      // probably edges of the projections when no extent is defined\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const errorThresholdInPixels =\r\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution\r\n    );\r\n\r\n    if (this.triangulation_.getTriangles().length === 0) {\r\n      // no valid triangles -> EMPTY\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\r\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\r\n\r\n    if (maxSourceExtent) {\r\n      if (sourceProj.canWrapX()) {\r\n        sourceExtent[1] = clamp(\r\n          sourceExtent[1],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3]\r\n        );\r\n        sourceExtent[3] = clamp(\r\n          sourceExtent[3],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3]\r\n        );\r\n      } else {\r\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\r\n      }\r\n    }\r\n\r\n    if (!getArea(sourceExtent)) {\r\n      this.state = TileState.EMPTY;\r\n    } else {\r\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\r\n        sourceExtent,\r\n        this.sourceZ_\r\n      );\r\n\r\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\r\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\r\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\r\n          if (tile) {\r\n            this.sourceTiles_.push(tile);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.sourceTiles_.length === 0) {\r\n        this.state = TileState.EMPTY;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the HTML Canvas element for this tile.\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const sources = [];\r\n    this.sourceTiles_.forEach((tile) => {\r\n      if (tile && tile.getState() == TileState.LOADED) {\r\n        sources.push({\r\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\r\n          image: tile.getImage(),\r\n        });\r\n      }\r\n    });\r\n    this.sourceTiles_.length = 0;\r\n\r\n    if (sources.length === 0) {\r\n      this.state = TileState.ERROR;\r\n    } else {\r\n      const z = this.wrappedTileCoord_[0];\r\n      const size = this.targetTileGrid_.getTileSize(z);\r\n      const width = typeof size === 'number' ? size : size[0];\r\n      const height = typeof size === 'number' ? size : size[1];\r\n      const targetResolution = this.targetTileGrid_.getResolution(z);\r\n      const sourceResolution = this.sourceTileGrid_.getResolution(\r\n        this.sourceZ_\r\n      );\r\n\r\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n        this.wrappedTileCoord_\r\n      );\r\n\r\n      this.canvas_ = renderReprojected(\r\n        width,\r\n        height,\r\n        this.pixelRatio_,\r\n        sourceResolution,\r\n        this.sourceTileGrid_.getExtent(),\r\n        targetResolution,\r\n        targetExtent,\r\n        this.triangulation_,\r\n        sources,\r\n        this.gutter_,\r\n        this.renderEdges_,\r\n        this.interpolate\r\n      );\r\n\r\n      this.state = TileState.LOADED;\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   */\r\n  load() {\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n\r\n      let leftToLoad = 0;\r\n\r\n      this.sourcesListenerKeys_ = [];\r\n      this.sourceTiles_.forEach((tile) => {\r\n        const state = tile.getState();\r\n        if (state == TileState.IDLE || state == TileState.LOADING) {\r\n          leftToLoad++;\r\n\r\n          const sourceListenKey = listen(\r\n            tile,\r\n            EventType.CHANGE,\r\n            function (e) {\r\n              const state = tile.getState();\r\n              if (\r\n                state == TileState.LOADED ||\r\n                state == TileState.ERROR ||\r\n                state == TileState.EMPTY\r\n              ) {\r\n                unlistenByKey(sourceListenKey);\r\n                leftToLoad--;\r\n                if (leftToLoad === 0) {\r\n                  this.unlistenSources_();\r\n                  this.reproject_();\r\n                }\r\n              }\r\n            },\r\n            this\r\n          );\r\n          this.sourcesListenerKeys_.push(sourceListenKey);\r\n        }\r\n      });\r\n\r\n      if (leftToLoad === 0) {\r\n        setTimeout(this.reproject_.bind(this), 0);\r\n      } else {\r\n        this.sourceTiles_.forEach(function (tile, i, arr) {\r\n          const state = tile.getState();\r\n          if (state == TileState.IDLE) {\r\n            tile.load();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSources_() {\r\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\r\n    this.sourcesListenerKeys_ = null;\r\n  }\r\n\r\n  /**\r\n   * Remove from the cache due to expiry\r\n   */\r\n  release() {\r\n    if (this.canvas_) {\r\n      releaseCanvas(this.canvas_.getContext('2d'));\r\n      canvasPool.push(this.canvas_);\r\n      this.canvas_ = null;\r\n    }\r\n    super.release();\r\n  }\r\n}\r\n\r\nexport default ReprojTile;\r\n", "/**\r\n * @module ol/source/TileImage\r\n */\r\nimport EventType from '../events/EventType.js';\r\nimport ImageTile from '../ImageTile.js';\r\nimport ReprojTile from '../reproj/Tile.js';\r\nimport TileCache from '../TileCache.js';\r\nimport TileState from '../TileState.js';\r\nimport UrlTile from './UrlTile.js';\r\nimport {equivalent, get as getProjection} from '../proj.js';\r\nimport {getKey, getKeyZXY} from '../tilecoord.js';\r\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\r\nimport {getUid} from '../util.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\r\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\r\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\r\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\r\n * @property {boolean} [opaque=false] Whether the layer is opaque.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\r\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\r\n * Higher values can increase reprojection performance, but decrease precision.\r\n * @property {import(\"./Source.js\").State} [state] Source state.\r\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\r\n * Default is {@link module:ol/ImageTile~ImageTile}.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\r\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\r\n * ```js\r\n * function(imageTile, src) {\r\n *   imageTile.getImage().src = src;\r\n * };\r\n * ```\r\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\r\n * service advertizes 256px by 256px tiles but actually sends 512px\r\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\r\n * should be set to `2`.\r\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\r\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\r\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\r\n * used instead of defining each one separately in the `urls` option.\r\n * @property {Array<string>} [urls] An array of URL templates.\r\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\r\n * request out-of-bounds tiles from the server. When set to `false`, only one\r\n * world will be rendered. When set to `true`, tiles will be requested for one\r\n * world only, but they will be wrapped horizontally to render multiple worlds.\r\n * @property {number} [transition] Duration of the opacity transition for rendering.\r\n * To disable the opacity transition, pass `transition: 0`.\r\n * @property {string} [key] Optional tile key for proper cache fetching\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\r\n * Choose whether to use tiles with a higher or lower zoom level when between integer\r\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for sources providing images divided into a tile grid.\r\n *\r\n * @fires import(\"./Tile.js\").TileSourceEvent\r\n * @api\r\n */\r\nclass TileImage extends UrlTile {\r\n  /**\r\n   * @param {!Options} options Image tile options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      cacheSize: options.cacheSize,\r\n      opaque: options.opaque,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      tileGrid: options.tileGrid,\r\n      tileLoadFunction: options.tileLoadFunction\r\n        ? options.tileLoadFunction\r\n        : defaultTileLoadFunction,\r\n      tilePixelRatio: options.tilePixelRatio,\r\n      tileUrlFunction: options.tileUrlFunction,\r\n      url: options.url,\r\n      urls: options.urls,\r\n      wrapX: options.wrapX,\r\n      transition: options.transition,\r\n      interpolate:\r\n        options.interpolate !== undefined ? options.interpolate : true,\r\n      key: options.key,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      zDirection: options.zDirection,\r\n    });\r\n\r\n    /**\r\n     * @protected\r\n     * @type {?string}\r\n     */\r\n    this.crossOrigin =\r\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {typeof ImageTile}\r\n     */\r\n    this.tileClass =\r\n      options.tileClass !== undefined ? options.tileClass : ImageTile;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Object<string, TileCache>}\r\n     */\r\n    this.tileCacheForProjection = {};\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\r\n     */\r\n    this.tileGridForProjection = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.renderReprojectionEdges_ = false;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    if (this.tileCache.canExpireCache()) {\r\n      return true;\r\n    }\r\n    for (const key in this.tileCacheForProjection) {\r\n      if (this.tileCacheForProjection[key].canExpireCache()) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    const usedTileCache = this.getTileCacheForProjection(projection);\r\n\r\n    this.tileCache.expireCache(\r\n      this.tileCache == usedTileCache ? usedTiles : {}\r\n    );\r\n    for (const id in this.tileCacheForProjection) {\r\n      const tileCache = this.tileCacheForProjection[id];\r\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutterForProjection(projection) {\r\n    if (\r\n      this.getProjection() &&\r\n      projection &&\r\n      !equivalent(this.getProjection(), projection)\r\n    ) {\r\n      return 0;\r\n    }\r\n    return this.getGutter();\r\n  }\r\n\r\n  /**\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutter() {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Return the key to be used for all tiles in the source.\r\n   * @return {string} The key for all tiles.\r\n   */\r\n  getKey() {\r\n    let key = super.getKey();\r\n    if (!this.getInterpolate()) {\r\n      key += ':disable-interpolation';\r\n    }\r\n    return key;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {boolean} Opaque.\r\n   */\r\n  getOpaque(projection) {\r\n    if (\r\n      this.getProjection() &&\r\n      projection &&\r\n      !equivalent(this.getProjection(), projection)\r\n    ) {\r\n      return false;\r\n    }\r\n    return super.getOpaque(projection);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    const thisProj = this.getProjection();\r\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\r\n      return this.tileGrid;\r\n    }\r\n    const projKey = getUid(projection);\r\n    if (!(projKey in this.tileGridForProjection)) {\r\n      this.tileGridForProjection[projKey] =\r\n        getTileGridForProjection(projection);\r\n    }\r\n    return this.tileGridForProjection[projKey];\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../TileCache.js\").default} Tile cache.\r\n   */\r\n  getTileCacheForProjection(projection) {\r\n    const thisProj = this.getProjection();\r\n    if (!thisProj || equivalent(thisProj, projection)) {\r\n      return this.tileCache;\r\n    }\r\n    const projKey = getUid(projection);\r\n    if (!(projKey in this.tileCacheForProjection)) {\r\n      this.tileCacheForProjection[projKey] = new TileCache(\r\n        this.tileCache.highWaterMark\r\n      );\r\n    }\r\n    return this.tileCacheForProjection[projKey];\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {string} key The key set on the tile.\r\n   * @return {!ImageTile} Tile.\r\n   * @private\r\n   */\r\n  createTile_(z, x, y, pixelRatio, projection, key) {\r\n    const tileCoord = [z, x, y];\r\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\r\n      tileCoord,\r\n      projection\r\n    );\r\n    const tileUrl = urlTileCoord\r\n      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\r\n      : undefined;\r\n    const tile = new this.tileClass(\r\n      tileCoord,\r\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\r\n      tileUrl !== undefined ? tileUrl : '',\r\n      this.crossOrigin,\r\n      this.tileLoadFunction,\r\n      this.tileOptions\r\n    );\r\n    tile.key = key;\r\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!(ImageTile|ReprojTile)} Tile.\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    const sourceProjection = this.getProjection();\r\n    if (\r\n      !sourceProjection ||\r\n      !projection ||\r\n      equivalent(sourceProjection, projection)\r\n    ) {\r\n      return this.getTileInternal(\r\n        z,\r\n        x,\r\n        y,\r\n        pixelRatio,\r\n        sourceProjection || projection\r\n      );\r\n    }\r\n    const cache = this.getTileCacheForProjection(projection);\r\n    const tileCoord = [z, x, y];\r\n    let tile;\r\n    const tileCoordKey = getKey(tileCoord);\r\n    if (cache.containsKey(tileCoordKey)) {\r\n      tile = cache.get(tileCoordKey);\r\n    }\r\n    const key = this.getKey();\r\n    if (tile && tile.key == key) {\r\n      return tile;\r\n    }\r\n    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\r\n    const targetTileGrid = this.getTileGridForProjection(projection);\r\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\r\n      tileCoord,\r\n      projection\r\n    );\r\n    const newTile = new ReprojTile(\r\n      sourceProjection,\r\n      sourceTileGrid,\r\n      projection,\r\n      targetTileGrid,\r\n      tileCoord,\r\n      wrappedTileCoord,\r\n      this.getTilePixelRatio(pixelRatio),\r\n      this.getGutter(),\r\n      (z, x, y, pixelRatio) =>\r\n        this.getTileInternal(z, x, y, pixelRatio, sourceProjection),\r\n      this.reprojectionErrorThreshold_,\r\n      this.renderReprojectionEdges_,\r\n      this.getInterpolate()\r\n    );\r\n    newTile.key = key;\r\n\r\n    if (tile) {\r\n      newTile.interimTile = tile;\r\n      newTile.refreshInterimChain();\r\n      cache.replace(tileCoordKey, newTile);\r\n    } else {\r\n      cache.set(tileCoordKey, newTile);\r\n    }\r\n    return newTile;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!ImageTile} Tile.\r\n   * @protected\r\n   */\r\n  getTileInternal(z, x, y, pixelRatio, projection) {\r\n    let tile = null;\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    const key = this.getKey();\r\n    if (!this.tileCache.containsKey(tileCoordKey)) {\r\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\r\n      this.tileCache.set(tileCoordKey, tile);\r\n    } else {\r\n      tile = this.tileCache.get(tileCoordKey);\r\n      if (tile.key != key) {\r\n        // The source's params changed. If the tile has an interim tile and if we\r\n        // can use it then we use it. Otherwise we create a new tile.  In both\r\n        // cases we attempt to assign an interim tile to the new tile.\r\n        const interimTile = tile;\r\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key);\r\n\r\n        //make the new tile the head of the list,\r\n        if (interimTile.getState() == TileState.IDLE) {\r\n          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\r\n          tile.interimTile = interimTile.interimTile;\r\n        } else {\r\n          tile.interimTile = interimTile;\r\n        }\r\n        tile.refreshInterimChain();\r\n        this.tileCache.replace(tileCoordKey, tile);\r\n      }\r\n    }\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * Sets whether to render reprojection edges or not (usually for debugging).\r\n   * @param {boolean} render Render the edges.\r\n   * @api\r\n   */\r\n  setRenderReprojectionEdges(render) {\r\n    if (this.renderReprojectionEdges_ == render) {\r\n      return;\r\n    }\r\n    this.renderReprojectionEdges_ = render;\r\n    for (const id in this.tileCacheForProjection) {\r\n      this.tileCacheForProjection[id].clear();\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Sets the tile grid to use when reprojecting the tiles to the given\r\n   * projection instead of the default tile grid for the projection.\r\n   *\r\n   * This can be useful when the default tile grid cannot be created\r\n   * (e.g. projection has no extent defined) or\r\n   * for optimization reasons (custom tile size, resolutions, ...).\r\n   *\r\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\r\n   * @api\r\n   */\r\n  setTileGridForProjection(projection, tilegrid) {\r\n    const proj = getProjection(projection);\r\n    if (proj) {\r\n      const projKey = getUid(proj);\r\n      if (!(projKey in this.tileGridForProjection)) {\r\n        this.tileGridForProjection[projKey] = tilegrid;\r\n      }\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    super.clear();\r\n    for (const id in this.tileCacheForProjection) {\r\n      this.tileCacheForProjection[id].clear();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {ImageTile} imageTile Image tile.\r\n * @param {string} src Source.\r\n */\r\nfunction defaultTileLoadFunction(imageTile, src) {\r\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =\r\n    src;\r\n}\r\n\r\nexport default TileImage;\r\n"],
  "mappings": "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",
  "names": ["createOrUpdate", "scale", "Tile_default", "Tile_default", "state", "Tile_default", "Tile_default", "z", "x", "y", "pixelRatio", "render"]
}
