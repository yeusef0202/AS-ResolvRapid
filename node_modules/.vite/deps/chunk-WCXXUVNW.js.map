{
  "version": 3,
  "sources": ["../../ol/extent/Relationship.js", "../../ol/extent.js", "../../ol/math.js"],
  "sourcesContent": ["/**\r\n * @module ol/extent/Relationship\r\n */\r\n\r\n/**\r\n * Relationship to an extent.\r\n * @enum {number}\r\n */\r\nexport default {\r\n  UNKNOWN: 0,\r\n  INTERSECTING: 1,\r\n  ABOVE: 2,\r\n  RIGHT: 4,\r\n  BELOW: 8,\r\n  LEFT: 16,\r\n};\r\n", "/**\r\n * @module ol/extent\r\n */\r\nimport Relationship from './extent/Relationship.js';\r\nimport {assert} from './asserts.js';\r\n\r\n/**\r\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\r\n * @typedef {Array<number>} Extent\r\n * @api\r\n */\r\n\r\n/**\r\n * Extent corner.\r\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\r\n */\r\n\r\n/**\r\n * Build an extent that includes all given coordinates.\r\n *\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @return {Extent} Bounding extent.\r\n * @api\r\n */\r\nexport function boundingExtent(coordinates) {\r\n  const extent = createEmpty();\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    extendCoordinate(extent, coordinates[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} xs Xs.\r\n * @param {Array<number>} ys Ys.\r\n * @param {Extent} [dest] Destination extent.\r\n * @private\r\n * @return {Extent} Extent.\r\n */\r\nfunction _boundingExtentXYs(xs, ys, dest) {\r\n  const minX = Math.min.apply(null, xs);\r\n  const minY = Math.min.apply(null, ys);\r\n  const maxX = Math.max.apply(null, xs);\r\n  const maxY = Math.max.apply(null, ys);\r\n  return createOrUpdate(minX, minY, maxX, maxY, dest);\r\n}\r\n\r\n/**\r\n * Return extent increased by the provided value.\r\n * @param {Extent} extent Extent.\r\n * @param {number} value The amount by which the extent should be buffered.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n * @api\r\n */\r\nexport function buffer(extent, value, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0] - value;\r\n    dest[1] = extent[1] - value;\r\n    dest[2] = extent[2] + value;\r\n    dest[3] = extent[3] + value;\r\n    return dest;\r\n  }\r\n  return [\r\n    extent[0] - value,\r\n    extent[1] - value,\r\n    extent[2] + value,\r\n    extent[3] + value,\r\n  ];\r\n}\r\n\r\n/**\r\n * Creates a clone of an extent.\r\n *\r\n * @param {Extent} extent Extent to clone.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} The clone.\r\n */\r\nexport function clone(extent, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0];\r\n    dest[1] = extent[1];\r\n    dest[2] = extent[2];\r\n    dest[3] = extent[3];\r\n    return dest;\r\n  }\r\n  return extent.slice();\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {number} Closest squared distance.\r\n */\r\nexport function closestSquaredDistanceXY(extent, x, y) {\r\n  let dx, dy;\r\n  if (x < extent[0]) {\r\n    dx = extent[0] - x;\r\n  } else if (extent[2] < x) {\r\n    dx = x - extent[2];\r\n  } else {\r\n    dx = 0;\r\n  }\r\n  if (y < extent[1]) {\r\n    dy = extent[1] - y;\r\n  } else if (extent[3] < y) {\r\n    dy = y - extent[3];\r\n  } else {\r\n    dy = 0;\r\n  }\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Check if the passed coordinate is contained or on the edge of the extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @return {boolean} The coordinate is contained in the extent.\r\n * @api\r\n */\r\nexport function containsCoordinate(extent, coordinate) {\r\n  return containsXY(extent, coordinate[0], coordinate[1]);\r\n}\r\n\r\n/**\r\n * Check if one extent contains another.\r\n *\r\n * An extent is deemed contained if it lies completely within the other extent,\r\n * including if they share one or more edges.\r\n *\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {boolean} The second extent is contained by or on the edge of the\r\n *     first.\r\n * @api\r\n */\r\nexport function containsExtent(extent1, extent2) {\r\n  return (\r\n    extent1[0] <= extent2[0] &&\r\n    extent2[2] <= extent1[2] &&\r\n    extent1[1] <= extent2[1] &&\r\n    extent2[3] <= extent1[3]\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the passed coordinate is contained or on the edge of the extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X coordinate.\r\n * @param {number} y Y coordinate.\r\n * @return {boolean} The x, y values are contained in the extent.\r\n * @api\r\n */\r\nexport function containsXY(extent, x, y) {\r\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\r\n}\r\n\r\n/**\r\n * Get the relationship between a coordinate and extent.\r\n * @param {Extent} extent The extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\r\n *     import(\"./extent/Relationship.js\").Relationship).\r\n */\r\nexport function coordinateRelationship(extent, coordinate) {\r\n  const minX = extent[0];\r\n  const minY = extent[1];\r\n  const maxX = extent[2];\r\n  const maxY = extent[3];\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  let relationship = Relationship.UNKNOWN;\r\n  if (x < minX) {\r\n    relationship = relationship | Relationship.LEFT;\r\n  } else if (x > maxX) {\r\n    relationship = relationship | Relationship.RIGHT;\r\n  }\r\n  if (y < minY) {\r\n    relationship = relationship | Relationship.BELOW;\r\n  } else if (y > maxY) {\r\n    relationship = relationship | Relationship.ABOVE;\r\n  }\r\n  if (relationship === Relationship.UNKNOWN) {\r\n    relationship = Relationship.INTERSECTING;\r\n  }\r\n  return relationship;\r\n}\r\n\r\n/**\r\n * Create an empty extent.\r\n * @return {Extent} Empty extent.\r\n * @api\r\n */\r\nexport function createEmpty() {\r\n  return [Infinity, Infinity, -Infinity, -Infinity];\r\n}\r\n\r\n/**\r\n * Create a new extent or update the provided extent.\r\n * @param {number} minX Minimum X.\r\n * @param {number} minY Minimum Y.\r\n * @param {number} maxX Maximum X.\r\n * @param {number} maxY Maximum Y.\r\n * @param {Extent} [dest] Destination extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdate(minX, minY, maxX, maxY, dest) {\r\n  if (dest) {\r\n    dest[0] = minX;\r\n    dest[1] = minY;\r\n    dest[2] = maxX;\r\n    dest[3] = maxY;\r\n    return dest;\r\n  }\r\n  return [minX, minY, maxX, maxY];\r\n}\r\n\r\n/**\r\n * Create a new empty extent or make the provided one empty.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateEmpty(dest) {\r\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromCoordinate(coordinate, dest) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  return createOrUpdate(x, y, x, y, dest);\r\n}\r\n\r\n/**\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromCoordinates(coordinates, dest) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendCoordinates(extent, coordinates);\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromFlatCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  dest\r\n) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\r\n}\r\n\r\n/**\r\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromRings(rings, dest) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendRings(extent, rings);\r\n}\r\n\r\n/**\r\n * Determine if two extents are equivalent.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {boolean} The two extents are equivalent.\r\n * @api\r\n */\r\nexport function equals(extent1, extent2) {\r\n  return (\r\n    extent1[0] == extent2[0] &&\r\n    extent1[2] == extent2[2] &&\r\n    extent1[1] == extent2[1] &&\r\n    extent1[3] == extent2[3]\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if two extents are approximately equivalent.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @param {number} tolerance Tolerance in extent coordinate units.\r\n * @return {boolean} The two extents differ by less than the tolerance.\r\n */\r\nexport function approximatelyEquals(extent1, extent2, tolerance) {\r\n  return (\r\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\r\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\r\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\r\n    Math.abs(extent1[3] - extent2[3]) < tolerance\r\n  );\r\n}\r\n\r\n/**\r\n * Modify an extent to include another extent.\r\n * @param {Extent} extent1 The extent to be modified.\r\n * @param {Extent} extent2 The extent that will be included in the first.\r\n * @return {Extent} A reference to the first (extended) extent.\r\n * @api\r\n */\r\nexport function extend(extent1, extent2) {\r\n  if (extent2[0] < extent1[0]) {\r\n    extent1[0] = extent2[0];\r\n  }\r\n  if (extent2[2] > extent1[2]) {\r\n    extent1[2] = extent2[2];\r\n  }\r\n  if (extent2[1] < extent1[1]) {\r\n    extent1[1] = extent2[1];\r\n  }\r\n  if (extent2[3] > extent1[3]) {\r\n    extent1[3] = extent2[3];\r\n  }\r\n  return extent1;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n */\r\nexport function extendCoordinate(extent, coordinate) {\r\n  if (coordinate[0] < extent[0]) {\r\n    extent[0] = coordinate[0];\r\n  }\r\n  if (coordinate[0] > extent[2]) {\r\n    extent[2] = coordinate[0];\r\n  }\r\n  if (coordinate[1] < extent[1]) {\r\n    extent[1] = coordinate[1];\r\n  }\r\n  if (coordinate[1] > extent[3]) {\r\n    extent[3] = coordinate[1];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendCoordinates(extent, coordinates) {\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    extendCoordinate(extent, coordinates[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendFlatCoordinates(\r\n  extent,\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride\r\n) {\r\n  for (; offset < end; offset += stride) {\r\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendRings(extent, rings) {\r\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\r\n    extendCoordinates(extent, rings[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n */\r\nexport function extendXY(extent, x, y) {\r\n  extent[0] = Math.min(extent[0], x);\r\n  extent[1] = Math.min(extent[1], y);\r\n  extent[2] = Math.max(extent[2], x);\r\n  extent[3] = Math.max(extent[3], y);\r\n}\r\n\r\n/**\r\n * This function calls `callback` for each corner of the extent. If the\r\n * callback returns a truthy value the function returns that value\r\n * immediately. Otherwise the function returns `false`.\r\n * @param {Extent} extent Extent.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\r\n * @return {S|boolean} Value.\r\n * @template S\r\n */\r\nexport function forEachCorner(extent, callback) {\r\n  let val;\r\n  val = callback(getBottomLeft(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getBottomRight(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getTopRight(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getTopLeft(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get the size of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Area.\r\n * @api\r\n */\r\nexport function getArea(extent) {\r\n  let area = 0;\r\n  if (!isEmpty(extent)) {\r\n    area = getWidth(extent) * getHeight(extent);\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * Get the bottom left coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\r\n * @api\r\n */\r\nexport function getBottomLeft(extent) {\r\n  return [extent[0], extent[1]];\r\n}\r\n\r\n/**\r\n * Get the bottom right coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\r\n * @api\r\n */\r\nexport function getBottomRight(extent) {\r\n  return [extent[2], extent[1]];\r\n}\r\n\r\n/**\r\n * Get the center coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Center.\r\n * @api\r\n */\r\nexport function getCenter(extent) {\r\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\r\n}\r\n\r\n/**\r\n * Get a corner coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @param {Corner} corner Corner.\r\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\r\n */\r\nexport function getCorner(extent, corner) {\r\n  let coordinate;\r\n  if (corner === 'bottom-left') {\r\n    coordinate = getBottomLeft(extent);\r\n  } else if (corner === 'bottom-right') {\r\n    coordinate = getBottomRight(extent);\r\n  } else if (corner === 'top-left') {\r\n    coordinate = getTopLeft(extent);\r\n  } else if (corner === 'top-right') {\r\n    coordinate = getTopRight(extent);\r\n  } else {\r\n    assert(false, 13); // Invalid corner\r\n  }\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {number} Enlarged area.\r\n */\r\nexport function getEnlargedArea(extent1, extent2) {\r\n  const minX = Math.min(extent1[0], extent2[0]);\r\n  const minY = Math.min(extent1[1], extent2[1]);\r\n  const maxX = Math.max(extent1[2], extent2[2]);\r\n  const maxY = Math.max(extent1[3], extent2[3]);\r\n  return (maxX - minX) * (maxY - minY);\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @param {import(\"./size.js\").Size} size Size.\r\n * @param {Extent} [dest] Destination extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function getForViewAndSize(center, resolution, rotation, size, dest) {\r\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\r\n    center,\r\n    resolution,\r\n    rotation,\r\n    size\r\n  );\r\n  return createOrUpdate(\r\n    Math.min(x0, x1, x2, x3),\r\n    Math.min(y0, y1, y2, y3),\r\n    Math.max(x0, x1, x2, x3),\r\n    Math.max(y0, y1, y2, y3),\r\n    dest\r\n  );\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @param {import(\"./size.js\").Size} size Size.\r\n * @return {Array<number>} Linear ring representing the viewport.\r\n */\r\nexport function getRotatedViewport(center, resolution, rotation, size) {\r\n  const dx = (resolution * size[0]) / 2;\r\n  const dy = (resolution * size[1]) / 2;\r\n  const cosRotation = Math.cos(rotation);\r\n  const sinRotation = Math.sin(rotation);\r\n  const xCos = dx * cosRotation;\r\n  const xSin = dx * sinRotation;\r\n  const yCos = dy * cosRotation;\r\n  const ySin = dy * sinRotation;\r\n  const x = center[0];\r\n  const y = center[1];\r\n  return [\r\n    x - xCos + ySin,\r\n    y - xSin - yCos,\r\n    x - xCos - ySin,\r\n    y - xSin + yCos,\r\n    x + xCos - ySin,\r\n    y + xSin + yCos,\r\n    x + xCos + ySin,\r\n    y + xSin - yCos,\r\n    x - xCos + ySin,\r\n    y - xSin - yCos,\r\n  ];\r\n}\r\n\r\n/**\r\n * Get the height of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Height.\r\n * @api\r\n */\r\nexport function getHeight(extent) {\r\n  return extent[3] - extent[1];\r\n}\r\n\r\n/**\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {number} Intersection area.\r\n */\r\nexport function getIntersectionArea(extent1, extent2) {\r\n  const intersection = getIntersection(extent1, extent2);\r\n  return getArea(intersection);\r\n}\r\n\r\n/**\r\n * Get the intersection of two extents.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @param {Extent} [dest] Optional extent to populate with intersection.\r\n * @return {Extent} Intersecting extent.\r\n * @api\r\n */\r\nexport function getIntersection(extent1, extent2, dest) {\r\n  const intersection = dest ? dest : createEmpty();\r\n  if (intersects(extent1, extent2)) {\r\n    if (extent1[0] > extent2[0]) {\r\n      intersection[0] = extent1[0];\r\n    } else {\r\n      intersection[0] = extent2[0];\r\n    }\r\n    if (extent1[1] > extent2[1]) {\r\n      intersection[1] = extent1[1];\r\n    } else {\r\n      intersection[1] = extent2[1];\r\n    }\r\n    if (extent1[2] < extent2[2]) {\r\n      intersection[2] = extent1[2];\r\n    } else {\r\n      intersection[2] = extent2[2];\r\n    }\r\n    if (extent1[3] < extent2[3]) {\r\n      intersection[3] = extent1[3];\r\n    } else {\r\n      intersection[3] = extent2[3];\r\n    }\r\n  } else {\r\n    createOrUpdateEmpty(intersection);\r\n  }\r\n  return intersection;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @return {number} Margin.\r\n */\r\nexport function getMargin(extent) {\r\n  return getWidth(extent) + getHeight(extent);\r\n}\r\n\r\n/**\r\n * Get the size (width, height) of an extent.\r\n * @param {Extent} extent The extent.\r\n * @return {import(\"./size.js\").Size} The extent size.\r\n * @api\r\n */\r\nexport function getSize(extent) {\r\n  return [extent[2] - extent[0], extent[3] - extent[1]];\r\n}\r\n\r\n/**\r\n * Get the top left coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\r\n * @api\r\n */\r\nexport function getTopLeft(extent) {\r\n  return [extent[0], extent[3]];\r\n}\r\n\r\n/**\r\n * Get the top right coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\r\n * @api\r\n */\r\nexport function getTopRight(extent) {\r\n  return [extent[2], extent[3]];\r\n}\r\n\r\n/**\r\n * Get the width of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Width.\r\n * @api\r\n */\r\nexport function getWidth(extent) {\r\n  return extent[2] - extent[0];\r\n}\r\n\r\n/**\r\n * Determine if one extent intersects another.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent.\r\n * @return {boolean} The two extents intersect.\r\n * @api\r\n */\r\nexport function intersects(extent1, extent2) {\r\n  return (\r\n    extent1[0] <= extent2[2] &&\r\n    extent1[2] >= extent2[0] &&\r\n    extent1[1] <= extent2[3] &&\r\n    extent1[3] >= extent2[1]\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if an extent is empty.\r\n * @param {Extent} extent Extent.\r\n * @return {boolean} Is empty.\r\n * @api\r\n */\r\nexport function isEmpty(extent) {\r\n  return extent[2] < extent[0] || extent[3] < extent[1];\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function returnOrUpdate(extent, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0];\r\n    dest[1] = extent[1];\r\n    dest[2] = extent[2];\r\n    dest[3] = extent[3];\r\n    return dest;\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} value Value.\r\n */\r\nexport function scaleFromCenter(extent, value) {\r\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\r\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\r\n  extent[0] -= deltaX;\r\n  extent[2] += deltaX;\r\n  extent[1] -= deltaY;\r\n  extent[3] += deltaY;\r\n}\r\n\r\n/**\r\n * Determine if the segment between two coordinates intersects (crosses,\r\n * touches, or is contained by) the provided extent.\r\n * @param {Extent} extent The extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\r\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\r\n * @return {boolean} The segment intersects the extent.\r\n */\r\nexport function intersectsSegment(extent, start, end) {\r\n  let intersects = false;\r\n  const startRel = coordinateRelationship(extent, start);\r\n  const endRel = coordinateRelationship(extent, end);\r\n  if (\r\n    startRel === Relationship.INTERSECTING ||\r\n    endRel === Relationship.INTERSECTING\r\n  ) {\r\n    intersects = true;\r\n  } else {\r\n    const minX = extent[0];\r\n    const minY = extent[1];\r\n    const maxX = extent[2];\r\n    const maxY = extent[3];\r\n    const startX = start[0];\r\n    const startY = start[1];\r\n    const endX = end[0];\r\n    const endY = end[1];\r\n    const slope = (endY - startY) / (endX - startX);\r\n    let x, y;\r\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\r\n      // potentially intersects top\r\n      x = endX - (endY - maxY) / slope;\r\n      intersects = x >= minX && x <= maxX;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.RIGHT) &&\r\n      !(startRel & Relationship.RIGHT)\r\n    ) {\r\n      // potentially intersects right\r\n      y = endY - (endX - maxX) * slope;\r\n      intersects = y >= minY && y <= maxY;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.BELOW) &&\r\n      !(startRel & Relationship.BELOW)\r\n    ) {\r\n      // potentially intersects bottom\r\n      x = endX - (endY - minY) / slope;\r\n      intersects = x >= minX && x <= maxX;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.LEFT) &&\r\n      !(startRel & Relationship.LEFT)\r\n    ) {\r\n      // potentially intersects left\r\n      y = endY - (endX - minX) * slope;\r\n      intersects = y >= minY && y <= maxY;\r\n    }\r\n  }\r\n  return intersects;\r\n}\r\n\r\n/**\r\n * Apply a transform function to the extent.\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\r\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\r\n * @param {Extent} [dest] Destination extent.\r\n * @param {number} [stops] Number of stops per side used for the transform.\r\n * By default only the corners are used.\r\n * @return {Extent} Extent.\r\n * @api\r\n */\r\nexport function applyTransform(extent, transformFn, dest, stops) {\r\n  let coordinates = [];\r\n  if (stops > 1) {\r\n    const width = extent[2] - extent[0];\r\n    const height = extent[3] - extent[1];\r\n    for (let i = 0; i < stops; ++i) {\r\n      coordinates.push(\r\n        extent[0] + (width * i) / stops,\r\n        extent[1],\r\n        extent[2],\r\n        extent[1] + (height * i) / stops,\r\n        extent[2] - (width * i) / stops,\r\n        extent[3],\r\n        extent[0],\r\n        extent[3] - (height * i) / stops\r\n      );\r\n    }\r\n  } else {\r\n    coordinates = [\r\n      extent[0],\r\n      extent[1],\r\n      extent[2],\r\n      extent[1],\r\n      extent[2],\r\n      extent[3],\r\n      extent[0],\r\n      extent[3],\r\n    ];\r\n  }\r\n  transformFn(coordinates, coordinates, 2);\r\n  const xs = [];\r\n  const ys = [];\r\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\r\n    xs.push(coordinates[i]);\r\n    ys.push(coordinates[i + 1]);\r\n  }\r\n  return _boundingExtentXYs(xs, ys, dest);\r\n}\r\n\r\n/**\r\n * Modifies the provided extent in-place to be within the real world\r\n * extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection\r\n * @return {Extent} The extent within the real world extent.\r\n */\r\nexport function wrapX(extent, projection) {\r\n  const projectionExtent = projection.getExtent();\r\n  const center = getCenter(extent);\r\n  if (\r\n    projection.canWrapX() &&\r\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\r\n  ) {\r\n    const worldWidth = getWidth(projectionExtent);\r\n    const worldsAway = Math.floor(\r\n      (center[0] - projectionExtent[0]) / worldWidth\r\n    );\r\n    const offset = worldsAway * worldWidth;\r\n    extent[0] -= offset;\r\n    extent[2] -= offset;\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * Fits the extent to the real world\r\n *\r\n * If the extent does not cross the anti meridian, this will return the extent in an array\r\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\r\n * real world\r\n *\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection\r\n * @return {Array<Extent>} The extent within the real world extent.\r\n */\r\nexport function wrapAndSliceX(extent, projection) {\r\n  if (projection.canWrapX()) {\r\n    const projectionExtent = projection.getExtent();\r\n\r\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\r\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\r\n    }\r\n\r\n    wrapX(extent, projection);\r\n    const worldWidth = getWidth(projectionExtent);\r\n\r\n    if (getWidth(extent) > worldWidth) {\r\n      // the extent wraps around on itself\r\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\r\n    } else if (extent[0] < projectionExtent[0]) {\r\n      // the extent crosses the anti meridian, so it needs to be sliced\r\n      return [\r\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\r\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\r\n      ];\r\n    } else if (extent[2] > projectionExtent[2]) {\r\n      // the extent crosses the anti meridian, so it needs to be sliced\r\n      return [\r\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\r\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\r\n      ];\r\n    }\r\n  }\r\n\r\n  return [extent];\r\n}\r\n", "/**\r\n * @module ol/math\r\n */\r\n\r\n/**\r\n * Takes a number and clamps it to within the provided bounds.\r\n * @param {number} value The input number.\r\n * @param {number} min The minimum value to return.\r\n * @param {number} max The maximum value to return.\r\n * @return {number} The input number if it is within bounds, or the nearest\r\n *     number within the bounds.\r\n */\r\nexport function clamp(value, min, max) {\r\n  return Math.min(Math.max(value, min), max);\r\n}\r\n\r\n/**\r\n * Returns the square of the closest distance between the point (x, y) and the\r\n * line segment (x1, y1) to (x2, y2).\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {number} x1 X1.\r\n * @param {number} y1 Y1.\r\n * @param {number} x2 X2.\r\n * @param {number} y2 Y2.\r\n * @return {number} Squared distance.\r\n */\r\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  if (dx !== 0 || dy !== 0) {\r\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n    if (t > 1) {\r\n      x1 = x2;\r\n      y1 = y2;\r\n    } else if (t > 0) {\r\n      x1 += dx * t;\r\n      y1 += dy * t;\r\n    }\r\n  }\r\n  return squaredDistance(x, y, x1, y1);\r\n}\r\n\r\n/**\r\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\r\n * @param {number} x1 X1.\r\n * @param {number} y1 Y1.\r\n * @param {number} x2 X2.\r\n * @param {number} y2 Y2.\r\n * @return {number} Squared distance.\r\n */\r\nexport function squaredDistance(x1, y1, x2, y2) {\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Solves system of linear equations using Gaussian elimination method.\r\n *\r\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\r\n *                                     in row-major order.\r\n * @return {Array<number>} The resulting vector.\r\n */\r\nexport function solveLinearSystem(mat) {\r\n  const n = mat.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    // Find max in the i-th column (ignoring i - 1 first rows)\r\n    let maxRow = i;\r\n    let maxEl = Math.abs(mat[i][i]);\r\n    for (let r = i + 1; r < n; r++) {\r\n      const absValue = Math.abs(mat[r][i]);\r\n      if (absValue > maxEl) {\r\n        maxEl = absValue;\r\n        maxRow = r;\r\n      }\r\n    }\r\n\r\n    if (maxEl === 0) {\r\n      return null; // matrix is singular\r\n    }\r\n\r\n    // Swap max row with i-th (current) row\r\n    const tmp = mat[maxRow];\r\n    mat[maxRow] = mat[i];\r\n    mat[i] = tmp;\r\n\r\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\r\n    for (let j = i + 1; j < n; j++) {\r\n      const coef = -mat[j][i] / mat[i][i];\r\n      for (let k = i; k < n + 1; k++) {\r\n        if (i == k) {\r\n          mat[j][k] = 0;\r\n        } else {\r\n          mat[j][k] += coef * mat[i][k];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Solve Ax=b for upper triangular matrix A (mat)\r\n  const x = new Array(n);\r\n  for (let l = n - 1; l >= 0; l--) {\r\n    x[l] = mat[l][n] / mat[l][l];\r\n    for (let m = l - 1; m >= 0; m--) {\r\n      mat[m][n] -= mat[m][l] * x[l];\r\n    }\r\n  }\r\n  return x;\r\n}\r\n\r\n/**\r\n * Converts radians to to degrees.\r\n *\r\n * @param {number} angleInRadians Angle in radians.\r\n * @return {number} Angle in degrees.\r\n */\r\nexport function toDegrees(angleInRadians) {\r\n  return (angleInRadians * 180) / Math.PI;\r\n}\r\n\r\n/**\r\n * Converts degrees to radians.\r\n *\r\n * @param {number} angleInDegrees Angle in degrees.\r\n * @return {number} Angle in radians.\r\n */\r\nexport function toRadians(angleInDegrees) {\r\n  return (angleInDegrees * Math.PI) / 180;\r\n}\r\n\r\n/**\r\n * Returns the modulo of a / b, depending on the sign of b.\r\n *\r\n * @param {number} a Dividend.\r\n * @param {number} b Divisor.\r\n * @return {number} Modulo.\r\n */\r\nexport function modulo(a, b) {\r\n  const r = a % b;\r\n  return r * b < 0 ? r + b : r;\r\n}\r\n\r\n/**\r\n * Calculates the linearly interpolated value of x between a and b.\r\n *\r\n * @param {number} a Number\r\n * @param {number} b Number\r\n * @param {number} x Value to be interpolated.\r\n * @return {number} Interpolated value.\r\n */\r\nexport function lerp(a, b, x) {\r\n  return a + x * (b - a);\r\n}\r\n\r\n/**\r\n * Returns a number with a limited number of decimal digits.\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The input number with a limited number of decimal digits.\r\n */\r\nexport function toFixed(n, decimals) {\r\n  const factor = Math.pow(10, decimals);\r\n  return Math.round(n * factor) / factor;\r\n}\r\n\r\n/**\r\n * Rounds a number to the nearest integer value considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The nearest integer.\r\n */\r\nexport function round(n, decimals) {\r\n  return Math.round(toFixed(n, decimals));\r\n}\r\n\r\n/**\r\n * Rounds a number to the next smaller integer considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The next smaller integer.\r\n */\r\nexport function floor(n, decimals) {\r\n  return Math.floor(toFixed(n, decimals));\r\n}\r\n\r\n/**\r\n * Rounds a number to the next bigger integer considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The next bigger integer.\r\n */\r\nexport function ceil(n, decimals) {\r\n  return Math.ceil(toFixed(n, decimals));\r\n}\r\n"],
  "mappings": "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",
  "names": ["intersects"]
}
